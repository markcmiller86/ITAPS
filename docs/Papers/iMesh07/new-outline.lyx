#LyX 1.6.1 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass acmtrans
\begin_preamble
\usepackage{url}
\category{D.2.12}{Software Engineering}{Interoperability}
\category{D.2.13}{Software Engineering}{Reusable software}[reusable libraries]
\category{I.6.7}{Simulation and Modeling}{Simulation support systems}[environments]
\terms{Design, Performance}
\keywords{data structure independence, mesh-based simulations, mesh modification, software components}
\title{An Interoperable, Data-Structure-Neutral Component for Mesh Query and Manipulation}
\markboth{Carl Ollivier-Gooch et al.}{A Software Component for Mesh Query and Manipulation}
\author{CARL OLLIVIER-GOOCH\\ University of British Columbia \and LORI DIACHIN\\  Lawrence Livermore National Laboratory  \and MARK S. SHEPHARD\\ Rensselaer Polytechnic Institute \and  TIMOTHY TAUTGES\\ Argonne National Laboratory \and  JASON KRAFTCHECK\\ University of Wisconsin \and  VITUS LEUNG\\ Sandia National Laboratory \and XIAOJUAN LUO\\ Rensselaer Polytechnic Institute \and MARK MILLER\\ Lawrence Livermore National Laboratory }
\begin{abstract}Much of the effort required to create a new simulation code goes into developing infrastructure for mesh data manipulation, adaptive refinement, design optimization, and so forth. This infrastructure is an obvious target for code re-use, except that implementations of these functionalities are typically tied to specific data structures. In this paper, we describe a software component --- an abstract data model and programming interface --- designed to provide low-level mesh query and manipulation support for meshing and solution algorithms. The component's data model provides a data abstraction, completely hiding all details of how mesh data is stored, while its interface defines how applications can interact with that data. Because the component has been carefully designed to be general-purpose and efficient, it provides a practical platform for implementing high-level mesh operations independently of the underlying mesh data structures. After describing the data model and interface, we provide several usage examples, each of which has been used successfully with multiple implementations of the interface functionality. The overhead due to accessing mesh data through the interface rather than directly accessing the underlying mesh data is shown to be acceptably small. \end{abstract}
\end_preamble
\options acmtoms,letterpaper
\use_default_options false
\language english
\inputencoding auto
\font_roman times
\font_sans helvet
\font_typewriter courier
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics dvips
\paperfontsize default
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry false
\use_amsmath 0
\use_esint 0
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Title
An Interoperable, Data-Structure-Neutral Component for Mesh Query and Manipulati
on
\end_layout

\begin_layout Author
CARL OLLIVIER-GOOCH
\begin_inset Newline newline
\end_inset

 University of British Columbia 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 LORI DIACHIN 
\begin_inset Newline newline
\end_inset

 Lawrence Livermore National Laboratory 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 MARK S.
 SHEPHARD
\begin_inset Newline newline
\end_inset

 Rensselaer Polytechnic Institute 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 TIMOTHY TAUTGES
\begin_inset Newline newline
\end_inset

 Argonne National Laboratory 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 JASON KRAFTCHECK
\begin_inset Newline newline
\end_inset

 University of Wisconsin 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset


\noun on
 
\noun default
VITUS LEUNG
\begin_inset Newline newline
\end_inset

 Sandia National Laboratory 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

 XIAOJUAN LUO
\begin_inset Newline newline
\end_inset

 Rensselaer Polytechnic Institute 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
and
\end_layout

\end_inset

MARK MILLER
\begin_inset Newline newline
\end_inset

 Lawrence Livermore National Laboratory 
\end_layout

\begin_layout Abstract
Much of the effort required to create a new simulation code goes into developing
 infrastructure for mesh data manipulation, adaptive refinement, design
 optimization, and so forth.
 This infrastructure is an obvious target for code re-use, except that implement
ations of these functionalities are typically tied to specific data structures.
 In this paper, we describe a software component --- an abstract data model
 and programming interface --- designed to provide low-level mesh query
 and manipulation support for meshing and solution algorithms.
 The component's data model provides a data abstraction, completely hiding
 all details of how mesh data is stored, while its interface defines how
 applications can interact with that data.
 Because the component has been carefully designed to be general-purpose
 and efficient, it provides a practical platform for implementing high-level
 mesh operations independently of the underlying mesh data structures.
 After describing the data model and interface, we provide several usage
 examples, each of which has been used successfully with multiple implementation
s of the interface functionality.
 The overhead due to accessing mesh data through the interface rather than
 directly accessing the underlying mesh data is shown to be acceptably small.
 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
maketitle
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Introduction"

\end_inset


\end_layout

\begin_layout Standard
Developing new simulation software for problems described by partial differentia
l equations has become a relatively common but nonetheless still laborious
 task.
 Much of the effort required to create a new simulation code goes into developin
g infrastructure for mesh and geometry data manipulation, equation discretizatio
n, adaptive refinement, design optimization, and so forth.
 Because this infrastructure is common to many simulations, re-usable software
 for these tasks could be shared across many simulation codes and could
 significantly reduce both the time, effort, and expertise required to develop
 and maintain new simulation codes.
\end_layout

\begin_layout Standard
Currently, 
\emph on
libraries
\emph default
 are the most common mechanism for software re-use in scientific computing,
 including highly-successful examples for numerical linear algebra
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "BaGr97,petsc,eispack,lapack,linpack"

\end_inset

 and parallel partitioning and load balancing
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Devine2002,Zoltan,ParMETIS,Walshaw2007,Jostle"

\end_inset

.
 A key drawback in using libraries as a mechanism for software re-use is
 the difficulty in modifying an application already using one library so
 that it can use another.
 At a minimum, all symbol names from one library must be changed to names
 from the other.
 However, the difficulties really only begin there.
 Libraries of similar purpose often package functionality in very different
 ways.
 Consequently, data structures shared between application and library and
 even the control flow between application and library may need to be totally
 re-designed.
 This need to re-design an application --- or portions of it --- so that
 it can re-use some other piece of software is often termed an 
\emph on
impedance mismatch
\emph default
.
 The greater the impedance mismatch, the more effort is required to resolve
 it.
 This time-consuming re-design process can be a significant diversion from
 the central scientific investigation, so many application researchers are
 reluctant to undertake it.
 As a result, improvements in algorithms often take years to migrate from
 the research community into application simulations.
\end_layout

\begin_layout Standard

\emph on
Components
\emph default
 represent a higher level of abstraction than libraries.
 To quote from the Common Component Architecture Forum (CCA) website
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cca-forum"

\end_inset

, 
\end_layout

\begin_layout Quote
A 
\series bold
component
\series default
 is a software object, meant to interact with other components, encapsulating
 certain functionality or a set of functionalities.
 A component has a clearly defined interface and conforms to a prescribed
 behavior common to all components within an architecture....
\end_layout

\begin_layout Quote
The 
\series bold
component interface
\series default
 is a set of methods supported by a component, and type definitions for
 the data used for arguments to those methods.
 An interface itself is a type and can be an argument for a component method.
\end_layout

\begin_layout Standard
Essentially, a component defines both a 
\emph on
specification
\emph default
 for an application programming interface (API) and an abstract 
\emph on
data model
\emph default
 defining the semantics of the data that is passed through the interface.
 Returning to the familiar example of linear algebra, a numerical linear
 algebra component would define a standard interface for operations such
 as dot products, matrix-vector multiplication, and linear system solution.
 Its abstract data model would include objects such as vectors and matrices.
 A key advantage to components is that any application using a component
 can, 
\emph on
without modification
\emph default
, use another implementation of that same component, because all compliant
 implementations necessarily have equivalent functionality.
 In other words, software re-use can be achieved with no additional effort.
\end_layout

\begin_layout Standard
This paper describes a meshing component intended to support low-level mesh
 access and manipulation.
 In addition, this component is designed to support the requirements of
 solver applications, including the ability to define mesh subsets and to
 attach arbitrary user data to mesh entities.
 Finally, our mesh component interface is intended to be both language and
 data structure independent.
 In summary, the mesh component we present is intended to support low-level
 interaction between applications programs --- both meshing and solution
 applications --- and external mesh databases regardless of the data structures
 and programming language used by each.
\end_layout

\begin_layout Standard
The most prominent example of prior research in defining interfaces for
 meshing is the Unstructured Grid Consortium (UGC), a working group of the
 American Institute for Aeronautics and Astronautics's Meshing, Visualization,
 and Computing Environments Technical Committee
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "UGC-web"

\end_inset

.
 The first release of the UGC interface
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "UGC-v1"

\end_inset

 was aimed at high level mesh operations, including mesh generation and
 quality assessment.
 Recognizing a need for additional and lower-level functionality, the UGC
 has developed an interface for defining generic high-level services, as
 well as a low-level query and modification interface for mesh databases
 aimed exclusively at meshing operations
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "UGC-v2:paper"

\end_inset

; results of such queries in the UGC interface are explicitly expressed
 as integer indices into data arrays, with obvious implications for how
 implementations of that interface must store data.
 The low-level UGC interface is similar in scope to our API, although we
 have deliberately been more general in providing support for functionality
 required by solvers and in emphasizing data structure neutrality.
\end_layout

\begin_layout Standard
In addition, several efforts have been made to define common interfaces
 to mesh data in the context of writing meshes to disk files.
 Two examples are the HDF Mesh API
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "hdf5:homepage,hdf5:meshAPI"

\end_inset

 and the CFD General Notation System (CGNS)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cgns:homepage,cgns2002"

\end_inset

.
 These efforts are similar in spirit, though they are either not complete
 enough (e.g.
 provide no mechanism to annotate mesh with other data) or address mesh
 data with a different level of abstraction than that chosen in our work.
\end_layout

\begin_layout Subsection
A Simple Use Case for a Mesh Component
\begin_inset CommandInset label
LatexCommand label
name "sub:Simple-Use-Case"

\end_inset


\end_layout

\begin_layout Standard
As an example of how a typical scientific computing application might benefit
 from using a mesh component, let us consider a finite element solver (FESolve)
 for some partial differential equation, and how this application might
 evolve over time.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
While different applications will surely have different requirements for
 interacting with unstructured mesh data, many, if not most, applications
 will follow roughly this same outline.
\end_layout

\end_inset

 Let us assume that when first developed, FESolve is a simple finite element
 solver, using linear elements.
 At run time, FESolve loads a mesh from a file and does some pre-processing
 of the mesh to compute geometric quantities (such as integration points
 and weights) and perhaps to compute some mesh topological relationships
 that weren't in the file.
 Then, FESolve iterates over the elements in the mesh, computing the residual
 and the stiffness matrix for each, and assembling these into a global linear
 system.
 This system is solved, and the solution is updated at every node.
 This iteration process may be repeated several times, e.g., for time-dependent
 or non-linear problems.
\end_layout

\begin_layout Standard
After FESolve has been in use for some time, its developers decide that
 mesh adaptation is required to improve solution accuracy and/or efficiency.
 With current approaches to developing mesh infrastructure software, they
 have two fundamentally different choices.
 One choice is to select some existing mesh adaptation code written by some
 other researcher(s) and integrate it with FESolve by resolving whatever
 impedance mismatch may exist.
 In many cases, this will require replacing the entire mesh database and
 infrastructure in FESolve with new software infrastructure from the mesh
 adaptation code, including updating FESolve to access data in a totally
 different way.
 The other choice is to ignore all existing mesh adaptation implementations
 and develop, from scratch, an implementation that is specifically tailored
 to fit into FESolve's current architecture.
 Of course, there are hybrid solutions which combine these two approaches.
\end_layout

\begin_layout Standard
A standard mesh component provides a third, less painful way to make this
 transition.
 Let us assume that there exists a stand-alone service that provides key
 mesh adaptation operations such as element division and coarsening.
 A mesh component interface can serve as the intermediary between the provider
 of mesh data (in this case, FESolve) and users of mesh data (in this case,
 the mesh adaptation service).
 The interface specifies a set of fundamental mesh query and manipulation
 operations.
 In essence, a mesh component interface proclaims 
\begin_inset Quotes eld
\end_inset

If you are going to ask me about a mesh, these are the questions you can
 ask and this is how you ask them.
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

If you are going to operate on a mesh, these are the operations you can
 perform and this how you perform them.
\begin_inset Quotes erd
\end_inset

 The component's data model specifies how mesh data is encapsulated.
\end_layout

\begin_layout Standard
When using a standard mesh component and a compliant adaptation service,
 the developers of FESolve are now required only to provide implementations
 of the component functionality used by the adaptation code.
 That is, if the mesh adaptation code uses only a handful of the queries
 and operations in the mesh component interface, then only this handful
 of functions needs to be added to FESolve.
 Once done, FESolve's data, in its own internal data structures, can be
 used directly by the mesh adaptation code without further integration.
 As a bonus, in implementing part of the mesh component interface, the FESolve
 development team will have done some of the work required to integrate
 other useful advanced capabilities available through the mesh component.
\end_layout

\begin_layout Subsection
The ITAPS Mesh Component
\begin_inset CommandInset label
LatexCommand label
name "sub:iMesh-component"

\end_inset


\end_layout

\begin_layout Standard
In this paper, we will describe a newly developed component intended to
 provide support for the mesh access and manipulation requirements of practical,
 large-scale scientific computing applications.
 This component, developed as part of a larger project by the Interoperable
 Tools for Advanced Petascale Simulation (ITAPS) center to develop interoperable
 software tools for meshes, domain geometry, and solution representation
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "tstt:overview"

\end_inset

, is called iMesh.
 Note the words 
\begin_inset Quotes eld
\end_inset

support for
\begin_inset Quotes erd
\end_inset

: the iMesh component is not intended to be a general interface to all possible
 meshing operations, but rather, to define the operations required at a
 mesh database level so that high-level operations --- including mesh generation
, mesh improvement, mesh adaptation, parallel partitioning, load balancing,
 and design optimization --- can be implemented as 
\emph on
services
\emph default
 that store and manipulate mesh data by using the iMesh component and mesh
 databases that implement the component's functionality.
 To be genuinely useful to real applications and real application developers,
 the component must be
\end_layout

\begin_layout Itemize
general purpose: most common mesh operations must be implementable based
 on the iMesh component, 
\end_layout

\begin_layout Itemize
efficient: data access using the iMesh component and its implementations
 must not come at too high a cost in overhead, 
\end_layout

\begin_layout Itemize
flexible: different applications may want to use different approaches for
 the same task, and 
\end_layout

\begin_layout Itemize
interoperable: implementations of the component must be truly interchangeable,
 and services designed to use the component should work on a plug and play
 basis, regardless of data structures and programming language.
 
\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Design-Principles"

\end_inset

 describes the design principles we followed to ensure that the iMesh component
 met these goals.
 We first defined a data model (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Data-Model"

\end_inset

): meshing operations require information about mesh entities (like vertices,
 triangular faces, and hexahedral regions), collections of entities, and
 meta-data associated with mesh entities.
 Using that data model, we then defined an API that would support general
 meshing and mesh-related solver operations (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Interface-Functionality"

\end_inset

).
 In addition to defining the iMesh component interface, we have also developed
 implementations of it based on existing mesh databases and used these implement
ations for various meshing and PDE solution tasks; several examples will
 be given in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Usage-Examples"

\end_inset

.
 The paper will conclude with discussion of lessons learned from developing
 this component, of the current status of software using the iMesh component,
 and of future prospects for extension and application of the iMesh component.
\end_layout

\begin_layout Section
Design Principles
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Design-Principles"

\end_inset


\end_layout

\begin_layout Standard
In Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:iMesh-component"

\end_inset

, we summarized our goals for the iMesh component.
 As design of the component interface continued, we found that several principle
s recurred frequently in guiding our design decisions as we worked towards
 those goals.
 Specifically, we found that we made decisions to produce an interface that
 was:
\end_layout

\begin_layout Description
Comprehensive.
 Clearly, a minimal requirement is that most typical mesh operations must
 be possible, either intrinsically through the iMesh component API or by
 building on it.
 
\end_layout

\begin_layout Description
Run-time
\begin_inset space ~
\end_inset

efficiency.
 For the iMesh component to be useful for applications, it must have low
 overhead.
 Specifically, the component interface must be designed so that an iMesh
 implementation can provide data access and manipulation nearly as rapidly
 as native access to the same mesh database.
 An example of the application of this principle in the iMesh component
 interface are the availability of both single-entity and array-of-entities
 access to mesh data, either of which may be more efficient depending on
 the circumstances.
 
\end_layout

\begin_layout Description
Ease
\begin_inset space ~
\end_inset

of
\begin_inset space ~
\end_inset

use.
 To lower the barrier for adoption of the interface, it must be relatively
 easy for programmers to use.
 This implies the interface must be relatively compact but also provide
 direct access to commonly used constructs, even at the expense of additional
 functions in the interface.
 For example, we recognize that certain types of metadata -- specifically,
 double, integer, and entity handle metadata -- will be very common and
 more easily handled both by iMesh implementations and applications if there
 are specific functions for these types.
 However, to preserve flexibility in such cases, we also provide general
 access mechanisms; for the metadata example, generic data is described
 using byte strings.
 Contrariwise, where this can be done without loss of functionality, we
 prefer to use a single, more general function rather than a collection
 of specific functions to reduce the number of functions programmers must
 learn and use; for example, all requests for entities adjacent to a given
 entity use the same function, rather than having separate functions for
 each possible adjacency.
\end_layout

\begin_layout Description
Flexibility.
 We recognize that different applications may choose to express the same
 semantic content in different ways.
 Where feasible, the iMesh interface supports this.
 For example, one application may choose to represent boundary condition
 data by metadata attached to particular mesh entities; another may represent
 the same information by collecting those entities into a set and annotating
 the set instead.
 As another example, some applications may choose to access data entity
 by entity while others may prefer array access to data.
 
\end_layout

\begin_layout Description
Extensibility.
 We have designed the interface to allow extensions to the low-level mesh
 access functionality that the interface defines.
 For example, ongoing work for a parallel extension to the iMesh interface
 leverages serial iMesh functionality for parallel usage.
 
\end_layout

\begin_layout Description
Interoperability.
 In the long-term, success of the iMesh component will depend on how well
 the component truly supports interoperability.
 This is the key to being able to leverage the effort in development of
 both implementations and services as well as conversion of applications
 to use the interface.
 Interoperability, in turn, requires not only the use of a standard interface,
 but also data structure and programming language neutrality.
  Also, interoperability can be enhanced by eliminating gray areas, where
 component behavior is implementation-dependent.
\end_layout

\begin_layout Section
Data Model
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Data-Model"

\end_inset


\end_layout

\begin_layout Standard
In the iMesh data model, all mesh primitives --- vertices (0D), edges (1D),
 faces (2D), and regions (3D) --- are referred to as 
\emph on
entities
\emph default
.
 
\emph on
Entity sets 
\emph default
are collections of mesh entities and other sets..
 All topological and geometric mesh data,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout

\emph on
Geometric mesh data
\emph default
 is geometric data required to define shapes of mesh entities.
 This is distinct from 
\emph on
geometric model data
\emph default
, which defines the shape of the problem domain.
\end_layout

\end_inset

 as well as all other entity sets, are contained in a 
\emph on
root entity set
\emph default
.
 To provide a scope for mesh data and to allow representation of multiple
 meshes, each root set is treated by the iMesh data model as an 
\emph on
instance
\emph default
, which is analogous to a C++ object, though it need not be implemented
 this way (in this analogy, the iMesh interface definition is, loosely,
 a C++ class).
 In many implementations, the instance will be a database or collection
 of containers storing all of the mesh entities, with other entity sets
 containing handles for these entities rather than copies of all entity
 data.
 Any iMesh data object --- an entity or any entity set including the root
 set --- can have one or more 
\emph on
tags
\emph default
 associated with it, so that arbitrary data can be attached to the object.
 To preserve data structure neutrality, all iMesh data objects are identified
 by opaque handles.
 The interface makes no assumptions about the way these handles represent
 data; in particular, pointer and integer handles are treated identically
 in the interface and have been used in implementations.
\end_layout

\begin_layout Subsection
Mesh Entities
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Mesh-Entities"

\end_inset


\end_layout

\begin_layout Standard
All the primitive constituents of a mesh are defined by the iMesh data model
 as 
\emph on
entities
\emph default
.
 iMesh entities are distinguished by their entity 
\emph on
type
\emph default
 (vertex, edge, face, or region: effectively, their topological dimension)
 and 
\emph on
topology
\emph default
 (for example, triangle, quadrilateral, or tetrahedron).
 Each topology has a unique entity type associated with it.
 Examples of entities include vertices, edges, triangular or quadrilateral
 faces in 2D or 3D, and tetrahedral or hexahedral regions in 3D; a complete
 catalog of entities supported by iMesh is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Mesh-Entities"

\end_inset

.
 Higher-dimensional entities are defined by lower-dimensional entities using
 a canonical ordering.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/canonical.fig
	width 80col%

\end_inset

 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="7">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Entity
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Canonical Ordering of Faces
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tetrahedron
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\triangle$
\end_inset

124
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\triangle$
\end_inset

234
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\triangle$
\end_inset

314
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\triangle$
\end_inset

132
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
---
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
---
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pyramid
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\triangle$
\end_inset

125
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\triangle$
\end_inset

235
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\triangle$
\end_inset

345
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\triangle$
\end_inset

415
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

4321
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
---
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prism
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

1254
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

2365
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

3146
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\triangle$
\end_inset

132
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\triangle$
\end_inset

456
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
---
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hexahedron
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

1265
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

2376
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

3487
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

4158
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

4321
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

5678
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Septahedron
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\triangle$
\end_inset

125
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

2365
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

3476
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

4157
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\square$
\end_inset

4321
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\triangle$
\end_inset

567
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Entities supported by the iMesh component.
 Canonical edge ordering is indicated in the sketch; canonical face ordering
 is given in the table.
 Polygons and polyhedra intrinsically have no canonical ordering.
\begin_inset CommandInset label
LatexCommand label
name "fig:Mesh-Entities"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Adjacencies describe how mesh entities connect to each other.
 For an entity of dimension 
\begin_inset Formula $d$
\end_inset

, a first-order adjacency request returns all of the mesh entities of dimension
 
\begin_inset Formula $q$
\end_inset

 which are on the closure of the entity for downward adjacency (
\begin_inset Formula $d>q$
\end_inset

), or for which the entity is part of the closure for upward adjacency (
\begin_inset Formula $d<q$
\end_inset

), as shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Adjacency"

\end_inset

(a) and
\begin_inset space ~
\end_inset

(b).
 For an entity of dimension 
\begin_inset Formula $d$
\end_inset

, second-order adjacencies describe all of the mesh entities of dimension
 
\begin_inset Formula $q$
\end_inset

 that share any adjacent entities of dimension 
\begin_inset Formula $b$
\end_inset

, where 
\begin_inset Formula $d\neq b$
\end_inset

 and 
\begin_inset Formula $b\neq q$
\end_inset

.
 Second-order adjacencies can be derived from first-order adjacencies.
 Note that, in the iMesh data model, requests such as all vertices that
 are neighbors to a given vertex are requests for second-order adjacencies.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Adjacency"

\end_inset

(c) highlights all edges adjacent to vertices adjacent to the shaded face.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/downward.eps
	width 30text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Downward adjacency; edges adjacent to a face, vertices adjacent to an edge.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/upward.eps
	width 30text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Upward adjacency: edges adjacent to a vertex, faces adjacent to an edge.
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/second.eps
	width 30text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Second adjacency; red edges are adjacent to vertices adjacent to the red
 face.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Examples of adjacency relationships between mesh entities.
\begin_inset CommandInset label
LatexCommand label
name "fig:Adjacency"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Entity Sets
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Entity-Sets"

\end_inset


\end_layout

\begin_layout Standard
The iMesh data model allows arbitrary groupings of entities, called 
\emph on
entity sets
\emph default
.
 Each entity set may be a true set (in the set theoretic sense) or it may
 be a (possibly non-unique) ordered list of entities; in the latter case,
 entities are retrieved in the order in which they were added to the entity
 set.
 An entity set may or may not be a simply-connected computational mesh;
 entity sets that 
\emph on
are
\emph default
 simple meshes have obvious application in multiblock and multigrid contexts,
 for instance.
 Entity sets (other than the root set) are populated by addition or removal
 of entities from the set.
 In addition, set Boolean operations --- subtraction, intersection, and
 union --- on entity sets are also supported.
\end_layout

\begin_layout Standard
Two primary relationships among entity sets are supported.
 First, entity sets may contain one or more entity sets (by definition,
 all entity sets belong to the root set).
 An entity set contained in another may be either a subset or an element
 (each in the set theoretic sense) of that entity set.
 The choice between these two interpretations is left to the application;
 the iMesh component does not impose either interpretation.
 Set contents can be queried recursively or non-recursively; in the former
 case, if entity set A is contained in entity set B, a request for the contents
 of B will include the entities in A (and the entities in sets contained
 in A).
 Second, parent/child relationships between entity sets are used to represent
 logical relationships between sets, including multigrid and adaptive mesh
 sequences.
 These logical relationships naturally form a directed, acyclic graph.
\end_layout

\begin_layout Standard
Examples of entity sets include the ordered list of vertices bounding a
 geometric face, the set of all mesh faces that lie on that geometric face,
 the set of regions assigned to a single processor by mesh partitioning,
 and the set of all entities in a given level of a multigrid mesh sequence.
\end_layout

\begin_layout Standard
For use with most solution applications, information in the root set or
 one or more of its constituent entity sets is typically a valid mesh for
 some scientific computing task, examples of which include:
\end_layout

\begin_layout Itemize
A non-overlapping, connected set of iMesh entities; for example, the structured
 and unstructured meshes commonly used in finite element simulations (
\emph on
simple mesh
\emph default
).
 
\end_layout

\begin_layout Itemize
Overlapping grids in which a collection of simple meshes are used to represent
 some portion of the computational domain, including chimera, multiblock,
 and multigrid meshes (
\emph on
multiple mesh
\emph default
).
 The interfaces presented here handle these mesh types in a general way;
 higher-level services may be added later to support specific functionalities
 needed by these meshes.
 In this case, each of the simple meshes is a valid computational mesh,
 stored as an entity set.
 
\end_layout

\begin_layout Itemize
Adaptive meshes in which all entities in a sequence of refined (simple or
 multiple) meshes are retained in the root set.
 The most highly refined adaptation level typically comprises a simple or
 multiple mesh.
 Typically, different levels of mesh adaptation will be represented by different
 entity sets, with many of the entities shared by multiple entity sets.
 
\end_layout

\begin_layout Itemize
Smooth particle hydrodynamic (SPH) meshes, which consist of a collection
 of iMesh vertices with no connectivity or adjacency information.
 
\end_layout

\begin_layout Standard
Meshing applications will typically have a valid computational mesh as their
 end product, though during processing the mesh database will often not
 be in this state.
\end_layout

\begin_layout Subsection
Tags
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Tags"

\end_inset


\end_layout

\begin_layout Standard
Tags are used as containers for user-defined data that can be attached to
 iMesh entities and entity sets.
 Different values of a particular tag can be associated with different entities
 or sets; for instance, a boundary condition tag will have different values
 for an inflow boundary than for a no-slip wall, and no value at all for
 faces in the interior of the mesh.
 In the general case, iMesh tags do not have a predefined type and allow
 the user to attach arbitrary data to mesh entities; this data is stored
 and retrieved by implementations as a byte pattern.
 To improve performance and ease of use, we support three specialized tag
 types: integers, doubles, and entity handles.
 These typed tags enable an iMesh implementation to correctly save and restore
 tag data when a mesh is written to a file.
\end_layout

\begin_layout Section
Interface Functionality
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Interface-Functionality"

\end_inset


\end_layout

\begin_layout Standard
The iMesh interface supports a variety of commonly needed functionalities
 for mesh and entity query, mesh modification, entity set operations, and
 tags.
 All data passed through the interface is in the form of opaque handles
 to objects defined in the data model.
 In this section we describe the functionality available through the iMesh
 interface.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note that these descriptions do not include detailed syntax, which can be
 found in the interface user guide
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "iBase-UG,iMesh-UG"

\end_inset

.
 Also, note that all function names in the interface are prepended by iMesh_;
 this prefix is omitted in the tables in this paper for compactness.
\end_layout

\end_inset

 For a reference implementation and simple usage examples, see the ITAPS
 web site
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "itaps:http"

\end_inset

.
\end_layout

\begin_layout Subsection
Global Queries
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Mesh-Interface"

\end_inset


\end_layout

\begin_layout Standard
Global query functions can be categorized into two groups: 1) 
\emph on
database functions
\emph default
, that manipulate the properties of the database as a whole and 2) 
\emph on
set query functions
\emph default
, that query the contents of entity sets as a whole; these functions require
 an entity set argument, which may be the root set.
 These functions are summarized in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "table:Mesh-Int"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Functions for Global Queries.
 (All function names are prepended with iMesh_.)
\begin_inset CommandInset label
LatexCommand label
name "table:Mesh-Int"

\end_inset

 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="17" columns="2">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="223pt">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Function
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
newMesh
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Creates a new, empty mesh instance
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
dtor
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Destroys a mesh instance
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
load
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Loads mesh data from file into entity set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
save
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Saves data from entity set to file
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getRootSet
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns handle for the root set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getGeometricDim
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns geometric dimension of mesh
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
setGeometricDim
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Sets geometric dimension of mesh (must not contain data yet)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getDfltStorage
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Tells whether implementation prefers blocked or interleaved coordinate data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getAdjTable
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns table indicating availability and cost of entity adjacency data
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
setAdjTable
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Specifies requirements for entity adjacencies and iterators
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
areEHValid
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns true if EH remain unchanged since last user-requested status reset
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getNumOfType
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns number of entities of type in ES
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getNumOfTopo
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns number of entities of topo in ES
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntities
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns all entities in ES of the given type and topology
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getVtxArrCoords
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
For all input vertex handles, return coords; storage order can be user-specified.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getAdjEntIndices
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size scriptsize
\emph off
\bar no
\noun off
\color none
Given ES and optionally a type or topology, return: EH's in ES of the specified
 type or topology; EH's adjacent to those entities with a specified type,
 as a list of unique handles; and for each entity in the first list, the
 adjacent entities specified as indices into the second list.
 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Database functions include functions to create and destroy mesh instances;
 note that the create function only sets up data structures for the mesh
 instance, which must be filled by reading data from a file or by creating
 a mesh entity by entity.
 The load and save functions read and write mesh information from files;
 file format and read/write options are implementation dependent.
 As mesh data is loaded, entities are stored in the root set, and can optionally
 be placed into a subsidiary entity set as well.
 iMesh implementations must be able to provide coordinate information in
 both blocked (xxx...yyy...zzz...) and interleaved (xyzxyzxyz...) formats; an application
 can query the implementation to determine the implementation's preferred
 storage order.
 
\end_layout

\begin_layout Standard
For a particular implementation, not all first-order adjacencies are necessarily
 available.
 For instance, in a classic finite element element-node connectivity storage,
 requests for faces or edges adjacent to an entity may return nothing, because
 the implementation has no stored data to return.
 For first-order adjacencies that are available in the implementation, the
 implementation may store the adjacency information directly, or compute
 adjacencies by either a local traversal of the entity's neighborhood or
 by global traversal of the entity set.
 Each iMesh implementation must provide information about the availability
 and relative cost of first-order adjacency queries.
 Also, a service or application may specify which adjacencies it requires
 and what entity types it will iterate over; this information, which can
 be updated by the service or application as its needs change, can be used
 by implementations to optimize internal storage for minimum memory use
 and efficient data retrieval.
\end_layout

\begin_layout Standard
Set query functions allow an application to retrieve information about entities
 in a set.
 The entity set may be the root set, which will return selected contents
 of the entire database, or may be any subsidiary entity set.
 For example, functions exist to request the number of mesh entities of
 a given type or topology; the types and topologies are defined as enumerations.
 Applications can request handles for all entities of a given type or topology
 or handles for entities of a given type adjacent to all entities of a given
 type or topology.
 Also, vertex coordinates are available in either blocked or interleaved
 order.
 Coordinate requests can be made for the arrays of vertex handles returned
 by an adjacency call.
 Finally, for entities of a given type and topology, their adjacent entities
 of a given type can be returned, along with an array of compressed sparse
 row style indices into the global vertex coordinate array can be obtained
 for both entity and adjacent entity requests.
\end_layout

\begin_layout Subsection
Entity- and Array-Based Query
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Ent-Interface"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Functions for Single Entity Queries.
 (All function names are prepended with iMesh_.)
\begin_inset CommandInset label
LatexCommand label
name "table:Entity"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="223pt">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Function
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
initEntIter
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Create an iterator to traverse entities of type and topo in ES; return true
 if any entities exist
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getNextEntIter
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return true and a handle to next entity if there is one; false otherwise
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
resetEntIter
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Reset iterator to restart traverse from the first entity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
endEntIter
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Destroy iterator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntType
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return type of entity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntTopo
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return topology of entity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getVtxCoord
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return coordinates of a vertex
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntAdj
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return entities of given type adjacent to EH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEnt2ndAdj
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return entities of given type adjacent to entities of a second type adjacent
 to EH
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Functions for Block Entity Queries.
 (All function names are prepended with iMesh_.)
\begin_inset CommandInset label
LatexCommand label
name "table:EntArr"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="223pt">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Function
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
initEntArrIter
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Create a block iterator to traverse entities of type and topo in ES
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getNextEntArrIter
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return true and a block of handles if there are any; false otherwise
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
resetEntArrIter
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Reset block iterator to restart traverse from the first entity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
endEntArrIter
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Destroy block iterator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntArrType
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return type of each entity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntArrTopo
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return topology of each entity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntArrAdj
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return entities of type adjacent to each EH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntArr2ndAdj
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return entities of given type adjacent to entities of a second type adjacent
 to each EH
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The global queries described in the previous section are used to retrieve
 information about all entities in an entity set.
 While this is certainly a practical alternative for some types of problems
 and for small problem size, larger problems or situations involving mesh
 modification require access to single entities or to blocks of entities.
 The iMesh interface supports traversal and query functions for single entities
 and for blocks of entities; the query functions supported are entity type
 and topology, vertex coordinates, and entity adjacencies.
 Blocks of data are passed through the interface using arrays of entity
 handles.
 Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "table:Entity"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "table:EntArr"

\end_inset

 summarize these functions.
\end_layout

\begin_layout Subsection
Mesh Modification
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Mesh-Modification"

\end_inset


\end_layout

\begin_layout Standard
The iMesh interface supports mesh modification by providing a minimal set
 of operators for low-level modification; both single entity (see Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "table:Modify"

\end_inset

) and block versions (see Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "table:ModArr"

\end_inset

) of these operators are provided.
 High-level functionality, including mesh generation, quality assessment,
 and validity checking, can in principle be built from these operators,
 although in practice such functionality is more likely to be provided using
 intermediate-level services that perform complete unit operations, including
 vertex insertion and deletion with topology updates, edge and face swapping,
 and vertex smoothing.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Functions for Single Entity Mesh Modification.
 (All function names are prepended with iMesh_.)
\begin_inset CommandInset label
LatexCommand label
name "table:Modify"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="223pt">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Function
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
createVtx
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Create vertex at given location
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
setVtxCoords
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Changes coordinates of existing vertex
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
createEnt
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Create entity of given topology from lower-dimensional entities; return
 entity handle and creation status
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
deleteEnt
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Delete EH from the mesh
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Functions for Block Mesh Modification.
 (All function names are prepended with iMesh_.)
\begin_inset CommandInset label
LatexCommand label
name "table:ModArr"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="223pt">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Function
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
createVtxArr
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Create vertices at given location
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
setVtxArrCoords
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Changes coordinates of existing vertices
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
createEntArr
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Create entities of given topology from lower-dimensional entities; return
 entity handle and status
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
deleteEntArr
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Delete each EH from the mesh
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Geometry modification is achieved through functions that change vertex locations.
 Vertex locations are set at creation, and can be changed as required, for
 instance, by mesh smoothing or other vertex movement algorithms.
\end_layout

\begin_layout Standard
Topology modification is achieved through the creation and deletion of mesh
 entities.
 Creation of higher-dimensional entities requires specification, in canonical
 order, of an appropriate collection of lower-dimensional entities.
 For instance, a tetrahedron can be created using four vertices, six edges
 or four faces, but not from combinations of these.
 Upon creation, adjacency information properly connecting the new entity
 to its closure is set up by the implementation.
 Some implementations may allow the creation of duplicate entities (for
 example, two edges connecting the same two vertices), while others will
 respond to such a creation request by returning a copy of the already-existing
 entity.
\end_layout

\begin_layout Standard
Deletion of existing entities is typically done from highest to lowest dimension.
 The iMesh interface also allows the deletion of an entity with existing
 upward adjacencies (for instance, an edge that is still in use by one or
 more faces or regions); in this case, downward adjacency requests may be
 nonsensical.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Subsection
Entity Shape
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "sub:Entity-Shape"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/high-order-sketch.eps
	width 80text%

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Examples of high-order, curved mesh entities
\begin_inset CommandInset label
LatexCommand label
name "fig:High-order-entities"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Information about the shape of mesh entities is essential for support of
 high order accurate solution techniques.
 Complicating matters is the fact that representations of curved mesh entities
 can be formulated in more than one way, including interpolation, approximation,
 analytic forms, and CAD data.
 In each of these formulations, however, point-wise geometric information
 is typically used to build up the required higher-order shapes of mesh
 entities.
 For example, Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:High-order-entities"

\end_inset

 shows the Lagrange interpolating and Bezier approximating shapes for mesh
 entities with constant or variable orders with a set of nodes used to represent
 the higher-order shape for mesh edges and faces.
\end_layout

\begin_layout Plain Layout
iMesh support for curved mesh entities focuses on specifying which form
 of geometric approximation is in use --- so that an application capable
 of handling multiple types can distinguish between them --- and the locations
 of the control points.
 Mesh shape functionality is designed to make common usage --- notably equal-ord
er Lagrange finite elements --- easy, while still allowing less common,
 more complicated usage --- such as 
\begin_inset Formula $p$
\end_inset

-refinement, or spectral elements, for instance.
 As such, global functions exist for initializing mesh entity shapes across
 the entire mesh, including not only creation of high-order nodes but initializa
tion of their locations.
 At a more fine-grained level, nodes can be created in the same way as ordinary
 vertices (i.e., through a call to iMesh_createVtx[Arr]) and associated with
 higher-dimensional entities either entity-by-entity or node-by-node.
 For equal order entities, creation of and access to all high order nodes
 for a mesh entity and its closure (for example, all the nodes for a 27-node
 hexahedron) can be handled in a single call.
 Mixed-order elements require a lower-level approach from the application,
 but we expect that writers of 
\begin_inset Formula $p$
\end_inset

-refined finite-element solvers will have the expertise for this.
 Finally, adjacency information for high-order nodes --- such as the identities
 of all hexahedra incident on a mid-edge node --- is accessed by first finding
 the mesh entity that a node is associated with, and then finding adjacencies
 for that entity.
 The iMesh functions providing this functionality are summarized in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:EntShape"

\end_inset

.
\end_layout

\begin_layout Plain Layout
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Functions for High-Order Entity Shape
\begin_inset CommandInset label
LatexCommand label
name "tab:EntShape"

\end_inset

.
 (All function names are prepended with iMesh_.)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="21" columns="2">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="223pt">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Function
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
hasMeshShapes
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Determine whether the mesh contains high order shapes of given shape type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
createMeshShapes
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Create higher order shapes with the specified shape type and order for the
 mesh
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
hasEntShape
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Determine whether an entity has high order shapes of given shape type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntShapeOrder
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Get the order of the higher order mesh entity shape
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
createEntShapes
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Create high order shapes for a single entity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
deleteEntShapes
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Delete high order nodes for an entity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntShapes
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return high order nodes for an entity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
setVtxParam
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Set parametric coordinates of high order node
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getVtxParam
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Get parametric coordinates of high order node
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
setNodeToEnt
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Associate a high order node with a mesh entity
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntOfNode
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return the mesh entity associated with a high order node 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
hasEntArrShape
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Determine whether an array of entities have high order shapes of given shape
 type
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntArrShapeOrder
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Get the order of the high order mesh entity shape for multiple entities
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
createEntArrShapes
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Create high order shapes for multiple entities
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
deleteEntArrShapes
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Delete high order nodes for entities
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntArrShapes
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return high order nodes for entities
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
setVtxArrParam
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Set parametric coordinates of high order nodes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getVtxArrParam
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Get parametric coordinates of high order nodes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
setNodeArrToEnt
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Associate high order nodes with mesh entities
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntArrOfNode
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return the mesh entities associated with high order nodes 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Entity Sets
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Entity-Set-Interface"

\end_inset


\end_layout

\begin_layout Standard
Entity set functionality in the iMesh interface is divided into three parts:
 basic set functionality, hierarchical set relations, and set Boolean operations.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Functions for Basic Entity Set Functionality.
 (All function names are prepended with iMesh_.)
\begin_inset CommandInset label
LatexCommand label
name "table:EntSet"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="2">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="223pt">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Function
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
createEntSet
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Creates a new entity set (ordered and non-unique if isList is true)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
destroyEntSet
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Destroys existing entity set
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
isList
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return true if the set is ordered and non-unique
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getNumEntSets
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns number of entity sets contained in SH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntSets
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns entity sets contained in SH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
addEntSet
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Adds entity set SH1 as a member of SH2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
rmvEntSet
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Removes entity set SH1 as a member of SH2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
isEntSetContained
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns true if SH2 is a member of SH1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
addEntToSet
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Add entity EH to set SH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
rmvEntFromSet
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Remove entity EH from set SH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
addEntArrToSet
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Add array of entities to set SH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
rmvEntArrFromSet
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Remove array of entities from set SH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
isEntContained
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns true if EH is a member of SH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
isEntArrContained
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Check an array of entities for membership in SH
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Basic set functionality, summarized in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "table:EntSet"

\end_inset

, includes creating and destroying entity sets; adding and removing entities
 and sets; and several entity set specific query functions.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note that the global mesh query functions (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Mesh-Interface"

\end_inset

) and traversal functions (Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Ent-Interface"

\end_inset

) defined above can be used with the root set or any other entity set as
 their first argument.
\end_layout

\end_inset

 Entity sets can be either ordered and non-unique, or unordered and unique;
 an ordered set guarantees that set query results (including traversal)
 will always be given in the order in which entities were added to the set.
 The ordered/unordered status of an entity set must be specified when the
 set is created and can be queried.
\end_layout

\begin_layout Standard
Entity sets are created empty.
 Entities can be added to or removed from the set individually or in blocks;
 for ordered sets, the last of a number of duplicate entries will be the
 first to be deleted.
 Also, entity sets can be added to or removed from each other; note that,
 because all entities and sets are automatically contained in the root set
 from creation, calls that would add or remove an entity or set from the
 root set are not permitted.
 An entity set can also be queried to determine the number and handles of
 sets that it contains, and to determine whether a given entity or set belongs
 to that set.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Functions for Entity Set Relationships.
 (All function names are prepended with iMesh_.)
\begin_inset CommandInset label
LatexCommand label
name "table:SetRel"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="223pt">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Function
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
addPrntChld
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Create a parent (SH1) to child (SH2) relationship
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
rmvPrntChld
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Remove a parent (SH1) to child (SH2) relationship
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
isChildOf
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return true if SH2 is a child of SH1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getNumChld
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return number of children of SH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getChldn
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return children of SH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getNumPrnt
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return number of parents of SH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getPrnts
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return parents of SH
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Hierarchical relationships between entity sets are intended to describe,
 for example, multilevel meshes and mesh refinement hierarchies.
 The directional relationships implied here are labeled as parent-child
 relationships in the iMesh interface.
 Functions are provided to add, remove, count, and identify parents and
 children and to determine if one set is a child of another; see Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "table:SetRel"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Functions for Entity Set Boolean Operations.
 (All function names are prepended with iMesh_.)
\begin_inset CommandInset label
LatexCommand label
name "table:SetBool"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="2">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="223pt">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Function
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
subtract
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return set difference SH1-SH2 in SH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
intersect
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return set intersection of SH1 and SH2 in SH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
unite
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return set union of SH1 and SH2 in SH
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Set Boolean operations --- intersection, union, and subtraction --- are
 also defined by the iMesh interface; these functions are summarized in
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "table:SetBool"

\end_inset

.
 The definitions are intended to be compatible with their C++ standard template
 library (STL) counterparts, both for semantic clarity and so that STL algorithm
s can be used by implementations where appropriate.
 All set Boolean operations apply not only to 
\emph on
entity
\emph default
 members of the set, but also to 
\emph on
set
\emph default
 members.
 Note that set hierarchical relationships are not included: the set resulting
 from a set Boolean operation on sets with hierarchical relationships will
 
\emph on
not
\emph default
 have any hierarchical relationships defined for it, regardless of the input
 data.
 For instance, if one were to take the intersection of two directionally-coarsen
ed meshes (stored as sets) with the same parent mesh (also a set) in a multigrid
 hierarchy, there is no reason to expect that the resulting set will necessarily
 be placed in the multigrid hierarchy at all.
 On the other hand, if both of those directionally-coarsened meshes contain
 a set of boundary faces, then their intersection will contain that set
 as well.
\end_layout

\begin_layout Standard
While set Boolean operations are completely unambiguous for unordered entity
 sets, ordered sets make things more complicated.
 For operations in which one set is ordered and one unordered, the result
 set is unordered; its contents are the same as if an unordered set were
 created with the (unique) contents of the ordered set and the operation
 were then performed.
 In the case of two ordered sets, the iMesh specification tries to follow
 the spirit of the STL definition, with complications related to the possibility
 of multiple copies of a given entity handle in each set.
 We recognize that these rules are somewhat arbitrary, but have been unable
 to find a more systematic way of defining these operations for ordered
 sets.
 In the following discussion, assume that a given entity handle appears
 
\begin_inset Formula $m$
\end_inset

 times in the first set and 
\begin_inset Formula $n$
\end_inset

 times in the second set.
\end_layout

\begin_layout Itemize
For intersection of two ordered sets, the output set will contain 
\begin_inset Formula $\min\left(m,n\right)$
\end_inset

 copies of the entity handle.
 These will appear in the same order as in the first input set, with the
 first copies of the handle surviving.
 For example, intersection of the two sets 
\begin_inset Formula $A=\textrm{\{$abacdbca$\}}$
\end_inset

 and 
\begin_inset Formula $B=\{dadbac\}$
\end_inset

 will result in 
\begin_inset Formula $A\bigcap B=\{abacd\}$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Union of two ordered sets is easy: the output set is a concatenation of
 the input sets: 
\begin_inset Formula $A\bigcup B=\{abacdbcadadbac\}$
\end_inset

.
 
\end_layout

\begin_layout Itemize
Subtraction of two ordered sets results in a set containing 
\begin_inset Formula $\max\left(m-n,0\right)$
\end_inset

 copies of an entity handle.
 These will appear in the same order as in the first input set, with the
 first copies of the handle surviving.
 For example, 
\begin_inset Formula $A-B=\{abc\}$
\end_inset

.
 
\end_layout

\begin_layout Standard
Regardless of whether the entity members of an entity set are ordered or
 unordered, the set members are always unordered and unique, with correspondingl
y simple semantics for Boolean operations.
\end_layout

\begin_layout Subsection
Tags
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Tag-Interface"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Basic Tag Functions.
 (All function names are prepended with iMesh_.)
\begin_inset CommandInset label
LatexCommand label
name "table:Tags"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="223pt">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Name
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
createTag
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Creates a new tag of the given type and number of values
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
destroyTag
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Destroys the tag if no entity is using it or if force is true
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getTagName
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns tag ID string
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getTagSizeValues
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns tag size in number of values
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getTagSizeBytes
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Returns tag size in number of bytes
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getTagHandle
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return tag with given ID string, if it exists
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getTagType
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return data type of this tag
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getAllTags
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return handles of all tags associated with entity EH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getAllEntSetTags
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return handles of all tags associated with entity set SH
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tags are used to associate application-dependent data with a mesh, entity,
 or entity set.
 Basic tag functionality defined in the iMesh interface is summarized in
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "table:Tags"

\end_inset

, while functionality for setting, getting, and removing tag data is summarized
 in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "table:Tags2"

\end_inset

.
\end_layout

\begin_layout Standard
When creating a tag, the application must provide its data type and size,
 as well as a unique name.
 For generic tag data, the tag size specifies how many bytes of data to
 store; for other cases, the size tells how many values of that data type
 will be stored.
 The implementation is expected to manage the memory needed to store tag
 data.
 The name string and data size can be retrieved based on the tag's handle,
 and the tag handle can be found from its name.
 Also, all tags associated with a particular entity can be retrieved; this
 can be particularly useful in saving or copying a mesh.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Setting, Getting, and Removing Tag Data.
 (All function names are prepended with iMesh_.)
\begin_inset CommandInset label
LatexCommand label
name "table:Tags2"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="2">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="223pt">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Function
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
setData
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
The value in tag TH for entity EH is set to the first tagValSize bytes of
 the array
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textless
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

char
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
textgreater
\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout

{}
\end_layout

\end_inset

 tagVal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
setArrData
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
The value in tag TH for entities in EHarray[i] is set using data in the
 array<char> tagValArray and the tag size
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
setEntSetData
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
The value in tag TH for entity set SH is set to the first tagValSize bytes
 of the array<char> tagVal
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
set[Int,Dbl,EH]Data
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
The value in tag TH for entity EH is set to the int, double, or entity handle
 in tagVal; array and entity set versions also exist.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getData
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return the value of tag TH for entity EH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getArrData
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Retrieve the value of tag TH for all entities in EH array, with data returned
 as an array of tagVal's
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntSetData
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return the value of tag TH for entity EH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
get[Int,Dbl,EH]Data
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Return the value of tag TH for entity EH; array and entity set versions
 also exist.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
rmvTag
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Remove tag TH from entity EH
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
rmvArrTag
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Remove tag TH from all entities in EH array
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
rmvEntSetTag
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Remove tag TH from entity set SH
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Initially, a tag is not associated with any entity or entity set, and no
 tag values exist; association is made explicitly by setting data for a
 tag-entity pair.
 Tag data can be set for single entities, arrays of entities (each with
 its own value), or for entity sets.
 In each of these cases, separate functions exist for setting generic tag
 data and type-specific data.
 Analogous data retrieval functions exist for each of these cases.
\end_layout

\begin_layout Standard
When an entity or set no longer needs to be associated with a tag --- for
 instance, a vertex was tagged for smoothing and the smoothing operation
 for that vertex is complete --- the tag can be removed from that entity
 without affecting other entities associated with the tag.
 When a tag is no longer needed at all --- for instance, when all vertices
 have been smoothed --- the tag can be destroyed through one of two variant
 mechanisms.
 First, an application can remove this tag from all tagged entities, and
 then request destruction of the tag.
 Simpler for the application is forced destruction, in which the tag is
 destroyed even though the tag is still associated with mesh entities, and
 all tag values and associations are deleted.
 Some implementations may not support forced destruction.
\end_layout

\begin_layout Subsection
Error Handling
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Error-Handling"

\end_inset


\end_layout

\begin_layout Standard
Like any API, the iMesh interface is vulnerable to errors, either through
 incorrect input or through internal failure within an implementation.
 For instance, it is an error for an application to request entities with
 conflicting types and topologies.
 Also, an error in the implementation occurs when memory for a new object
 cannot be allocated.
 The iMesh interface defines a number of standard error conditions which
 could occur in iMesh functions, either because of illegal input or internal
 implementation errors; each of these error conditions has an accompanying
 description, which can be retrieved by calling iMesh_getDescription, summarized
 in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "table:Error"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Error Handling Functionality.
 (All function names are prepended with iMesh_.)
\begin_inset CommandInset label
LatexCommand label
name "table:Error"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="223pt">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Name
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Description
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getDescription
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Retrieves error description
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Compliance Testing
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Compliance-Testing"

\end_inset


\end_layout

\begin_layout Standard
To ensure consistency between implementations and to assist users developing
 partial implementations based on their own mesh data structures, we have
 developed a comprehensive compliance test suite for the iMesh interface.
 When testing a full implementation of the interface, the test suite uses
 the iMesh implementation to read a mesh file, then tests each interface
 function.
 These tests are typically done by comparing information retrieved in multiple
 ways --- for instance, retrieving coordinate information in both blocked
 and interleaved order, or retrieving adjacency information entity-by-entity
 or for all entities of a given type.
 The set and tag functions can be easily tested by creating sets or tags
 in the test code and querying the new sets and tags to verify their correctness.
 We are currently working on a function-level compliance testing, so that
 users wishing to use a single iMesh-based service can implement and test
 only the functions required for that service.
 This fine-grained testing is much more difficult, because consistency between
 different calls can no longer be relied on.
 The combination of these two test suites will ensure that different iMesh
 implementations have the same behavior, and that applications can rely
 on correct interaction with iMesh services.
\end_layout

\begin_layout Subsection
Fortran Compatibility
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Fortran-Compatibility"

\end_inset


\end_layout

\begin_layout Standard
For compatibility with the Fortran convention that functions returning values
 do not modify their arguments, no iMesh function returns a value.
 That is, all iMesh functions are C void functions or Fortran subroutines.
 Also, string arguments in the C API have an accompanying argument giving
 their length; these string length arguments are added at the end of the
 argument list in the order the strings appear.
 Fortran77 and Fortran90/95 compilers must support the pass-by-value extension
 to be compatible with the iMesh API.
 Fortran 2003 has C interoperability features that greatly simply matters;
 we provide a Fortran 2003 module definition and examples online
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "itaps:http"

\end_inset

.
\end_layout

\begin_layout Section
Usage Examples
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Usage-Examples"

\end_inset


\end_layout

\begin_layout Standard
In this section, we provide several examples of using the iMesh component,
 including finite element simulation, mesh modification, mesh partitioning,
 and visualization.
 Each of these services has been demonstrated to work with multiple implementati
ons of the iMesh component, and --- where efficiency data are available
 --- the overhead of using the iMesh API rather than a native implementation
 is quite small.
 In addition to these examples of direct iMesh usage, members of our consortium
 are collaborating with applications researchers to introduce ITAPS software
 tools into applications in accelerator design, nuclear fusion, groundwater
 simulation, combustion, and computational biology; these efforts are not
 described in this paper.
\end_layout

\begin_layout Subsection
Existing iMesh Implementations
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Existing-iMesh-Implementations"

\end_inset


\end_layout

\begin_layout Standard
Before discussing applications of the iMesh interface, we will summarize
 the status of the existing iMesh implementations.
 Our consortium has produced a complete reference implementation of the
 iMesh interface as well as four complete implementations based on our pre-exist
ing mesh databases, all of which are available directly through our website
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "itaps:http"

\end_inset

; most also have their own websites.
 Each of the five supports all standard finite element topologies --- hexahedra,
 tetrahedra, prisms, pyramids, triangles, and quadrilaterals.
 Each has its own particular strengths and areas of most frequent application.
 
\end_layout

\begin_layout Itemize
The reference implementation (RefImpl) is intended as a basic mesh database
 with full support for all iMesh functionality.
 Users looking for a testbed for experimenting with iMesh or for implementing
 meshing algorithms without the difficulties of first writing a mesh database
 will find this implementation of particular interest.
\end_layout

\begin_layout Itemize
The Flexible Mesh DataBase (FMDB)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "ReSh03"

\end_inset

 is designed especially to handle adaptively changing mesh data, including
 flexible storage of adjacency information.
 Application usage of FMDB includes computational fluid dynamics (CFD),
 fusion, and accelerator simulations.
\end_layout

\begin_layout Itemize
The Mesh Oriented datABase (MOAB)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "moab"

\end_inset

 is particularly efficient in its memory management.
 Application usage for MOAB includes nuclear reactor modeling, neutron transport
, and accelerator design optimization.
\end_layout

\begin_layout Itemize
The Generation and Refinement of Unstructured Mixed-element Meshes in Parallel
 (GRUMMP)
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "GRUMMP:http"

\end_inset

 toolkit is designed for triangular/tetrahedral mesh generation, improvement,
 and adaptation, and is particularly efficient in retrieving adjacency informati
on.
 Application usage is primarily in CFD, especially aerodynamics and non-Newtonia
n fluid dynamics.
\end_layout

\begin_layout Itemize
The Pacific Northwest National Laboratory's NWGRID
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "nwgrid:http"

\end_inset

 is intended for adaptive mesh refinement, especially for simplicial meshes.
 Application usage includes computational biology, CFD, solid mechanics,
 and subsurface transport modeling.
\end_layout

\begin_layout Subsection
A Simple Finite Element Solver
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:FESolve"

\end_inset


\end_layout

\begin_layout Standard
To demonstrate the cost of using the iMesh interface in a typical computational
 science application, we developed a simple finite element application that
 solves a diffusion problem in two dimensions on the unit square:
\end_layout

\begin_layout Standard
\begin_inset Formula \begin{equation}
\nabla(k\nabla u(x,y))=f\end{equation}

\end_inset

 
\begin_inset Formula \begin{equation}
u(x=0)=0\quad u(x=1)=1\quad u_{x}(y=0)=0\quad u_{x}(y=1)=0.\end{equation}

\end_inset

The finite element solver uses linear triangular elements and exact integration
 rules.
 The finite element solver is written in C and uses PETSc to solve the linear
 systems.
\end_layout

\begin_layout Standard
We focus our attention on setting up the linear system and consider four
 different options for accessing the mesh data: 1) through array-based mechanism
s defined in the iMesh interface, which should approximate the performance
 of a native implementation; 2) through entity iterators; and 3) through
 entity array iterators.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
The native mesh data structures use linked lists to store the vertex and
 element information.
 Each vertex data structure includes its coordinate information, its global
 id, and an integer boundary flag.
 Each element data structure includes downward adjacency information to
 vertices, a global id, and the element area which is computed when the
 mesh is initialized.
 To access this same information through the iMesh interface requires copying
 data into arrays as needed and storing global ids, boundary flags, and
 element areas as tags.
\end_layout

\end_inset

Regardless of access method, we require for each vertex its coordinates;
 a global id and a boundary flag as stored attached to the vertices as tags.
 For elements, we require downward adjacency information (face to vertex)
 and store a global id and computed element area as tags.
 We make use of the iMesh functions given in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "table:FEfunctions"

\end_inset

.
 In all cases, we must obtain the root set from the iMesh instance and get
 the tag handles for the global ids, boundary flags and element areas.
 In the case of array access, we obtain a lists of all the vertex and face
 entities in the mesh and can obtain the tag data as arrays of size 
\emph on
num_vtx
\emph default
 or 
\emph on
num_elem
\emph default
.
 We can obtain the vertex coordinate information and element connectivity
 information using these entity arrays or, as we did in this example, directly
 from the mesh data base.
 It is guaranteed by the iMesh interface that the information returned using
 these array-based calls will have a consistent ordering across all calls.
 The iMesh calls used for the entity and entity array iterators provide
 the same functionality either entity by entity or for arrays of entities.
 In each case, we initialize the iterator to return mesh faces and get entity
 information through the getNextEnt(Arr)Iter function.
 For each entity (array) returned, we obtain the downward vertex adjacency
 information, the vertex coordinates, and needed global id, boundary, and
 element area tag data.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
iMesh functions used in the simple finite element solver for different mesh
 data access
\begin_inset CommandInset label
LatexCommand label
name "table:FEfunctions"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="3">
<features>
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="1.25in">
<column alignment="none" valignment="top" width="1.25in">
<row>
<cell alignment="none" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Array Access
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Entity Iterator
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
Entity Array Iterator
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getRootSet
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getRootSet
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getRootSet
\size default
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getTagHandle
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getTagHandle
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getTagHandle
\size default
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getVtxCoordIndex
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
initEntIter
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
initEntArrIter
\size default
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getAllVtxCoords
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getNextEntIter
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getNextEntArrIter
\size default
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntities
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntAdj
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getEntArrAdj
\size default
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getIntArrData
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getVtxCoord
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getVtxArrCoords
\size default
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getDblArrData
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getIntData
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getIntArrData
\size default
 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="none" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getDblArrData
\size default
 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size scriptsize
getDblArrData
\size default
 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This application has been timed with two iMesh implementations, GRUMMP and
 SimpleMesh, a small-scale test implementation developed at Lawrence Livermore;
 the application has also been tested successfully with other iMesh implementati
ons, although timings are not reported here.
 We ran each case 40 times and report the average time required to set up
 the linear system in milliseconds, along with the percentage increase in
 cost compared to the use of problem-sized arrays, in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "table:FEtimes"

\end_inset

.
 In the case of the entity array iterator, we used array sizes of 1, 3,
 5, 10 and 20.
 This is a small problem size; the total number of elements in the mesh
 is 6077, so the largest array iterator represents only about 0.3% of the
 total problem size.
 Not surprisingly, the array based access to the vertex and element information
 is the fastest.
 Entity iterators are perhaps the most natural to program, but result in
 the highest overhead costs due to the very large number of function calls
 (
\begin_inset Formula $10+3\cdot(n_{e}+n_{e}\cdot n_{v})+4\cdot n_{v}$
\end_inset

), where 
\begin_inset Formula $n_{e}$
\end_inset

 is the number of elements and 
\begin_inset Formula $n_{v}$
\end_inset

 is the number of vertices; for the SimpleMesh implementation, the overhead
 is only 6.6%, but for the GRUMMP implementation it is a much higher 27.6%.
 The entity array iterator cases decrease in cost as the array size grows
 and number of function calls decreases; in this case, the total number
 of iMesh function calls is 
\begin_inset Formula $10+6*n_{e}/\left|WS\right|+4*n_{v}/\left|WS\right|$
\end_inset

, where 
\begin_inset Formula $\left|WS\right|$
\end_inset

 is the size of the work set; for both implementations, the overhead is
 reduced by at least a factor of two compared with entity iterators.
\end_layout

\begin_layout Standard
\begin_inset Float table
placement htb
wide false
sideways false
status open

\begin_layout Plain Layout
 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Timing results for the 2D linear finite element solver using the SimpleMesh
 implementation of the iMesh interface.
\begin_inset CommandInset label
LatexCommand label
name "table:FEtimes"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="5">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Case 
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SimpleMesh 
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GRUMMP
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{(T-T_{\mbox{array}})}{T_{\mbox{array}}}\times100$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time (ms)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\frac{(T-T_{\mbox{array}})}{T_{\mbox{array}}}\times100$
\end_inset

 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Array-based 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
81.8
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--- 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
86.7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
--- 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Entity Iterator 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
87.2
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.6% 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
110.6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
27.6%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Entity Array Iterator (1) 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
87.6
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7.1% 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
109.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 25.8%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Entity Array Iterator (3) 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
86.2
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6.7% 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
102.5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 18.2%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Entity Array Iterator (5) 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
85.3
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.3% 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
99.0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 14.1%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Entity Array Iterator (10) 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
85.4
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.5% 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
97.4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 12.3%
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Entity Array Iterator (20) 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
84.4
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.3% 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
95.9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
 10.6%
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Mesh Quality Improvement via Vertex Movement
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Mesh-Vert-Opt"

\end_inset


\end_layout

\begin_layout Standard
The MESh QUality Improvement Toolkit (Mesquite)
\begin_inset CommandInset citation
LatexCommand cite
key "Mesquite03"

\end_inset

 improves the accuracy of mesh-based simulations through optimization of
 the mesh vertex locations.
 Mesquite can be used for element shape optimization, r-adaptivity, mesh
 alignment, etc., and has been tested with the MOAB, FMDB, GRUMMP and NWGRID
 iMesh implementations.
\end_layout

\begin_layout Standard
As input Mesquite requires an iMesh instance and entity set handle designating
 the subset of the mesh over which to perform the optimization.
 If the entity set handle is the root set, optimization is done for the
 entire mesh.
 Further, Mesquite expects an integer tag indicating whether the corresponding
 vertex may be moved during optimization.
 Generally, boundary vertices are marked as fixed or otherwise constrained
 to the computational domain boundary to ensure correct problem formulation.
 While there is some variation in iMesh functionality requirements in the
 different Mesquite solvers, all Mesquite optimization algorithms require
 iteration over elements and vertices contained in an entity set, element-vertex
 adjacency queries, entity set creation and modification,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is an artifact of early versions of both Mesquite and the iMesh interface.
 The Mesquite-iMesh interaction code could be updated to remove the need
 for this capability.
\end_layout

\end_inset

 vertex coordinate query and modification, and tag data query.
 These capabilities are sufficient to support Mesquite's global element
 shape optimizer; a sample input mesh is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:msq-shape"

\end_inset

(a) with the corresponding output mesh in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:msq-shape"

\end_inset

(b).
 When optimizing a single vertex or subsets of mesh vertices, iMesh implementati
on must also efficiently determine the elements adjacent to a vertex.
 Output results were identical for both the global and Laplacian smoothers,
 and for data access using Mesquite's native mesh representation and via
 the iMesh interface.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Initial mesh
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename msq/corners.eps
	width 30text%

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Optimized mesh
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename msq/direct.eps
	width 30text%

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Optimized mesh using target matrix optimization
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename msq/target.eps
	width 30text%

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Element shape optimization using Mesquite.
\begin_inset CommandInset label
LatexCommand label
name "fig:msq-shape"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename msq/bias.eps
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Initial mesh
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "c"
hor_pos "c"
has_inner_box 1
inner_pos "c"
use_parbox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
status open

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename msq/deformed.eps
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Deformed mesh
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename msq/def-opt.eps
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Optimized mesh
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Deforming boundary optimization using Mesquite.
\begin_inset CommandInset label
LatexCommand label
name "fig:msq-deform"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Mesquite is also capable of optimizing to obtain specific characteristics
 of the mesh on an element-by-element basis using target matrices.
 These pre-calculated target matrices are stored as iMesh tag data on the
 mesh elements and retrieved during optimization.
 For example, Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:msq-shape"

\end_inset

(c) is the result of optimizing the same input mesh given previously, except
 that target matrices are used to preserve the size and aspect ratio of
 the elements.
 Another example is shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:msq-deform"

\end_inset

 in which element aspect ratio is preserved while updating the mesh for
 a deforming mesh boundary.
 An initial anisotropic mesh, shown in Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:msq-deform"

\end_inset

(a), is used to calculate the target matrices.
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:msq-deform"

\end_inset

(b) shows the same mesh after boundary deformation, with some elements inverted
 due to the change in location of the boundary vertices.
 This mesh (with the stored target matrices) is the input to the Mesquite
 optimizer.
 The resulting mesh, with the element anisotropy preserved, is shown in
 Figure 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:msq-deform"

\end_inset

(c).
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
CPU Time (seconds) for optimization of 40,000 element meshes.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset CommandInset label
LatexCommand label
name "table:msq-times"

\end_inset

 
\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="7">
<features>
<column alignment="left" valignment="top" width="0">
<column alignment="right" valignment="top" width="0">
<column alignment="none" valignment="top" width="0" special="@{.}l">
<column alignment="right" valignment="top" width="0">
<column alignment="none" valignment="top" width="0" special="@{.}l">
<column alignment="right" valignment="top" width="0">
<column alignment="none" valignment="top" width="0" special="@{.}l">
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Optimizer 
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="none" valignment="top" topline="true" usebox="none" special="c|">
\begin_inset Text

\begin_layout Plain Layout
Internal
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="none" valignment="top" topline="true" usebox="none" special="c|">
\begin_inset Text

\begin_layout Plain Layout
iMesh
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="none" valignment="top" usebox="none" special="c|">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="none" valignment="top" topline="true" usebox="none" special="c|">
\begin_inset Text

\begin_layout Plain Layout
MOAB
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="none" valignment="top" topline="true" usebox="none" special="c|">
\begin_inset Text

\begin_layout Plain Layout
GRUMMP
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Global shape optimization 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
45 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Laplacian smoother 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
111 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
472 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
65 
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="none" valignment="top" topline="true" leftline="true" usebox="none" special="c|">
\begin_inset Text

\begin_layout Plain Layout
---
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Target matrix optimization 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
79 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
30 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
82 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
65 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
89 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
38 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deforming boundary 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
73 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
15 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
48 
\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
21 
\end_layout

\end_inset
</cell>
<cell alignment="none" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
59 
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "table:msq-times"

\end_inset

 shows the impact of the iMesh interface and implementation on optimizer
 performance.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The iMesh implementation in GRUMMP does not yet support vertex-to-element
 adjacency queries for surface meshes, so it was not possible to run this
 Laplacian smoothing example with the GRUMMP iMesh implementation.
\end_layout

\end_inset

 Each row of the table corresponds to one of the examples above with the
 mesh interval size reduced by a factor of ten, resulting in meshes with
 40,000 elements.
 The global shape optimization results demonstrate one of the advantages
 of using a mesh database library over a custom storage scheme.
 The more compact representation of data in the iMesh implementations results
 in a slight performance improvement over Mesquite's internal mesh representatio
n.
 The Laplacian smoothing times emphasize the overhead of a standard interface
 and generalized mesh database.
 The smoothing calculation is trivial.
 The time spent in tens of millions of queries for small amounts of data
 (adjacencies, tag data, vertex coordinates, etc.) dominates the run time
 of the optimization.
 The latter two rows in Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "table:msq-times"

\end_inset

 demonstrate the run time cost of accessing tag data.
 The time spent accessing other mesh data is the same as for the global
 shape optimization case.
 The difference in run time for each mesh database is entirely a function
 of the time spent querying target matrices stored in tag data.
\end_layout

\begin_layout Subsection
Mesh Quality Improvement via Topology Optimization
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sub:Mesh-Topo-Opt"

\end_inset


\end_layout

\begin_layout Standard
Local mesh topology optimization can be a powerful tool for improving the
 quality of unstructured meshes; however, mesh topology modification ---
 often referred to as swapping --- is difficult enough to implement that
 an iMesh-based service that performs these operations would be useful for
 many applications.
 The classic face and edge swapping operations
\begin_inset space ~
\end_inset

(see, for instance,
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Freitag1997"

\end_inset

 for a description) have been implemented using the iMesh API
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "TSTT-swap-tool"

\end_inset

.
\end_layout

\begin_layout Standard
The swapping service represents a worst-case scenario for efficiency tests
 for the iMesh interface, in that the service requires fine-grained access
 to and modification of the mesh database using the interface.
 As such, the swapping service makes a large number of calls through the
 interface, each returning a small amount of data.
 Specifically, the swapping service uses the iMesh entity iterators, adjacency
 queries, array-based vertex coordinate queries, checks for entity type
 and topology, and entity creation and deletion functions.
 Optionally, the swapping service can also be restricted to reconfigure
 only tetrahedra that are members of a given set, requiring the ability
 to query set membership and to assign new entities to sets.
 A second optional functionality is the ability to accept a tag and tag
 value to indicate which faces within a set should be considered for swapping.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Performance for the iMesh swapping service for a supersonic aircraft mesh
 (251,140 tetrahedra).
\begin_inset CommandInset label
LatexCommand label
name "tab:swapping-service"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Note Comment
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="5">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none" special="|c||">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none" special="c|">
\begin_inset Text

\begin_layout Plain Layout
Native
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" bottomline="true" usebox="none" special="c|">
\begin_inset Text

\begin_layout Plain Layout
iMesh implementations
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none" special="|c||">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(non-iMesh) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
GRUMMP 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FMDB 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MOAB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Swaps 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25,448 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28,629 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
27,811 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
27,592
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rate 
\begin_inset Formula $\left(\frac{1}{\mbox{sec}}\right)$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,380 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,800 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
223 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
122
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Memory (MB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
216 MB 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
292 MB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
622 MB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
110 MB
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="3">
<features>
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none" special="|c||">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none" special="c|">
\begin_inset Text

\begin_layout Plain Layout
Native
\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" rightline="true" usebox="none" special="c|">
\begin_inset Text

\begin_layout Plain Layout
GRUMMP
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none" special="|c||">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
(non-iMesh) 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
iMesh
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Swaps 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
25,448 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28,629 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Rate 
\begin_inset Formula $\left(\frac{1}{\mbox{sec}}\right)$
\end_inset

 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3,380 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2,800 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Memory (MB)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
216 MB 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
292 MB
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The swapping service has been tested with three different iMesh implementations:
 GRUMMP, MOAB, and FMDB, and the results compared with an implementation
 of the same algorithms using the GRUMMP back-end (referred to as 
\emph on
native
\emph default
).
 For testing purposes, we use a mesh for a supersonic aircraft initially
 containing 251,140 tetrahedra.
 Because of differences in the order in which faces are accessed, output
 meshes from the iMesh swapping service are not identical but we have confirmed
 elsewhere
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "TSTT-swap-tool"

\end_inset

 that the meshes have statistically indistinguishable quality.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:swapping-service"

\end_inset

 compares the number of swaps performed, the swapping rate, and the memory
 used for the native swapping implementation and the swapping service using
 the GRUMMP iMesh implementation.
 The CPU time overhead for using the GRUMMP iMesh implementation rather
 than the native implementation is about 20% for this case; the 40% overhead
 in memory usage is required to support certain forms of entity creation
 that are not supported natively by the mesh database.
 Preliminary timing results for the MOAB and FMDB databases suggest that,
 for this service, good performance depends on careful attention to optimization
 of frequently-called iMesh functions, especially iterators and adjacency
 retrieval; in some cases, design decisions in the mesh database may also
 have a significant impact on performance.
 
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:swapping-service"

\end_inset

 contains the number of swaps performed, the swapping rate, and the memory
 used for each implementation.
 The CPU time overhead for using the GRUMMP iMesh implementation rather
 than the native implementation is about 20% for this case; the 40% overhead
 in memory usage is required to support certain forms of entity creation
 that are not supported natively by the mesh database.
 The results for this case clearly show that the designers of the FMDB and
 MOAB mesh databases made different trade-offs in deciding what data to
 store and how.
 MOAB was designed for low memory usage --- less than 40% of the memory
 usage of the next smallest database here.
 FMDB was designed for parallel performance and flexibility, neither of
 which are required by this service.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:cpu-breakdown"

\end_inset

 shows relative CPU time for each implementation, broken down into the time
 spent in the swapping service itself; retrieving adjacency information;
 retrieving coordinate information; performing mesh modifications; reading
 and pre-processing mesh data; and manipulating iterators.
 The difference in relative cost for the swapping service reflects the differenc
e in total CPU time, as the absolute time for the driver varies by only
 about 10% between implementations.
 The most significant differences in overall performance are clearly in
 adjacency retrieval and iterators.
 Optimization of these routines would no doubt improve their performance
 significantly for this service and others that use the iMesh interface
 similarly.
 This case also illustrates clearly that efficient implementation of iMesh
 functions that are used heavily by a service is essential for good run-time
 performance.
\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Breakdown of relative CPU time for the swapping service with three different
 iMesh implementations
\begin_inset CommandInset label
LatexCommand label
name "fig:cpu-breakdown"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename pics/time-bar.png
	width 70text%

\end_inset

 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
A Partitioning Service
\end_layout

\begin_layout Standard
As a precursor to our ongoing work for a parallel extension to the iMesh
 interface, an iMesh-based service that performs partitioning would be useful.
 Partitioning distributes data over sets of processors and is needed by
 unstructured and/or adaptive parallel applications.
 Many of the partitioning methods in Zoltan
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Zoltan"

\end_inset

 have been made available in a service that uses the iMesh API to access
 mesh data.
 The partitioners available can be grouped into three categories; simple
 partitioners for testing and demonstration, geometric or coordinate-based
 partitioners, and graph partitioning.
\end_layout

\begin_layout Standard
For the simple partitioners, the partitioning service uses the iMesh queries
 for entities and number of entities.
 The partition service can operate at the level of any mesh entity (i.e.
 vertex, edge, face, or region).
 The partitioning service uses both single-entity and array-of-entities
 access to mesh data.
 For the geometric partitioners, the partitioning service uses the iMesh
 single-entity adjacency queries and array-based vertex coordinate queries.
 For graph partitioning, the partitioning service uses the array-based adjacency
 queries.
\end_layout

\begin_layout Standard
The partition data is stored by both attaching an integer tag to each mesh
 entity and collecting entities into sets with integer tags.
 Any previous partition data is destroyed before new partition data is created.
 The partition service uses entity set query, deletion, and creation functions
 as well as the ability to assign new entities to sets and get, destroy,
 create, and set tag data.
\end_layout

\begin_layout Standard
The partitioning service has been tested and is interoperable with three
 mesh database implementations available through the iMesh C interface:
 MOAB, FMDB, and GRUMMP.
 Users need only link in the desired implementation; no other changes are
 necessary.
 A partitioning service interfacing directly to MOAB performs only slightly
 faster than the partitioning service interfacing to MOAB through iMesh.
 To partition a mesh with 1.4 million faces by faces using recursive coordinate
 bisection, the MOAB native implementation required 37.2 seconds, while using
 the ITAPS C interface to access the MOAB data structures required 38.2 seconds
 (2.5% overhead).
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout

\series medium
RCB-FACE Partition Time in Seconds
\end_layout

\begin_layout Plain Layout

\series medium
# of triangles Native ITAPS SIDL ITAPS C 1,400,624 37.216974 55.625528 38.18318
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Visualization Using the iMesh Interface
\end_layout

\begin_layout Standard
Visualization and interactive manipulation of meshes as well as fields defined
 on meshes is important in many aspects of simulation software development.
 Towards this end, we have developed a VisIt
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "VisIt2005"

\end_inset

 plugin that accesses mesh and solution data through an iMesh implementation.
 We have demonstrated that the current plugin is interoperable across three
 different iMesh implementations: GRUMMP, MOAB and FMDB.
 The plugin uses array-based vertex coordinate queries.
 Solution data is retrieved using iMesh tag capabilities.
 In addition, the plugin uses recursive entity set queries to map an iMesh
 entity set hierarchy to a roughly equivalent VisIt construct called a 
\emph on
subset inclusion lattice
\emph default
.
 This enables VisIt to provide intuitive GUI controls to users in terms
 of subsets that are characteristic to various stages of their design and
 analysis workflows.
 For example, users often need to focus their attention on a specific part
 in the original CAD model, a specific regime in the material model, or
 a specific discretization region in the numerical model.
 The ability for users to interactively visualize, query, calculate and
 otherwise analyze data in terms of characteristic subsets such as these
 both within and across each stage of a design and analysis workflow fundamental
ly enhances the flexibility of the analysis activities possible within the
 VisIt visualization tool.
\end_layout

\begin_layout Subsection
Size Field-Based Mesh Adaptation
\end_layout

\begin_layout Standard
Adaptive methods are central to ensuring the accuracy and reliability of
 simulation results.
 One approach to supporting mesh adaptation is to provide a service that
 can take an existing mesh with a new mesh size field associated with it
 and create the desired adapted mesh by applying appropriate mesh modification
 operations.
 Such a service for anisotropic mesh adaptation has been under development
 of a number of years
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "LiSh05"

\end_inset

.
 To ensure the ability to deal with general curved geometries that can come
 from CAD systems, the service builds on a generalized interaction with
 the geometric model
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "BeWa04"

\end_inset

 and ensures the mesh can properly represent the domain of interest
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "LiSh03"

\end_inset

.
 This service has been used to construct adaptive simulation procedures
 by combining it with finite element and finite volume solvers, and associated
 error indicators.
 Since the mesh adaptation service works off a general anisotropic mesh
 size field, error indicators that have been used include various combinations
 of analytic fields, anisotropic 
\emph on
a posteriori
\emph default
 correction indicators and geometric approximation considerations
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "ShFl05,WaKo05"

\end_inset

.
 An example of a part before and after refinement using this approach is
 shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:adaptation"

\end_inset

.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Timing info: service vs.
 native
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Before refinement (408 regions)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/coarse.jpg
	width 40text%

\end_inset


\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
After refinement (36,261 regions)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename pics/refined.jpg
	width 40text%

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
An example of size field-based mesh adaptation.
\begin_inset CommandInset label
LatexCommand label
name "fig:adaptation"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The current version of the mesh adaptation service builds on the FMDB mesh
 library that employs mesh topology like iMesh.
 Although it is possible to replace all FMDB calls with iMesh calls in the
 mesh adaptation service code (an activity planned for the future), the
 size of the code and the desire to apply the mesh adaptation to applications
 quickly prompted us to take an alternative initial approach.
 In this approach, meshes are accessed through the iMesh functions and loaded
 into the FMDB structures.
 The mesh adaptation process is carried out and the resulting mesh is then
 put back into iMesh form.
 This approach has the disadvantage that at the beginning and end of the
 mesh adaptation process there are two copies of the mesh.
 However, since the size of the mesh is typically small compared to the
 structures used during the implicit finite element and finite volume solvers
 being used to date, there have not been memory limitations introduced by
 this process.
\end_layout

\begin_layout Section
Discussion and Conclusions
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:Discussion-and-Conclusions"

\end_inset


\end_layout

\begin_layout Standard
In this paper, we have described a new software component for mesh-based
 applications --- both meshing and solver applications.
 We have described in detail the key features of this software component,
 called iMesh: its data model --- which defines the types of data that the
 component works with --- and its interface --- which defines how applications
 can interact with mesh data.
\end_layout

\begin_layout Standard
Also, we have shown by example that iMesh component  is flexible enough
 for a wide range of applications --- including finite element solvers,
 mesh improvement and adaptation, partitioning, and visualization.
 Our experience with these examples shows that relatively complex mesh modificat
ion and solution requirements can be met by the interface, with low impact
 on efficiency.
 Specifically, for a simple finite element solver, overhead induced by using
 the iMesh interface is less than 10%, especially when data for multiple
 entities is retrieved through the mesh interface at once.
 For mesh smoothing, the overhead rate varied significantly from case to
 case, depending on the amount of work done by the smoothing code relative
 to the number of calls through the mesh interface.
 For mesh swapping, another fine-grained use case for the mesh component,
 overhead rates were about 20% compared with a native implementation of
 the same algorithms.
 Three higher-level services --- mesh partitioning, visualization, and mesh
 adaptation --- have also been tested across multiple iMesh implementations.
 In each case, the services have proved to be interoperable, and the overhead
 in using the iMesh interface is acceptable.
 Overall, our experience with these services confirms that relatively complex
 mesh operations can be performed correctly using the iMesh interface.
 Also, we have found clear examples of significant differences between mesh
 database designs in overall run time for a particular service.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Note that this is not contradictory with our finding of low overhead when
 comparing native and iMesh-based implementations, as the overhead measurements
 compare an iMesh implementation of a service to a non-iMesh implementation
 of that same functionality 
\emph on
for a given mesh database
\emph default
.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Several implementations of the iMesh component are currently available,
 as are the services described in this paper.
\begin_inset CommandInset citation
LatexCommand cite
key "itaps:http"

\end_inset

 An analogous software component for geometric query and manipulation for
 mesh-based applications has also been developed, and work is nearing completion
 on a parallel extension of the mesh component.
\end_layout

\begin_layout Subsection*
Acknowledgments
\end_layout

\begin_layout Standard
The authors would like to acknowledge the contributions of Kyle Chand and
 Tamara Dahlgren (Lawrence Livermore National Laboratories); Seegyoung Seol
 (Renssalaer Polytechnic Institute); Xiaolin Li and Brian Fix (Stony Brook
 University); and Harold Trease (Pacific Northwest National Laboratory)
 to the development of the ITAPS mesh component.
\end_layout

\begin_layout Standard
This work was funded by the U.S.
 Department of Energy under the Scientific Discovery through Advanced Computing
 (SciDAC) program and by the Canadian Natural Sciences and Engineering Research
 Council under a Special Research Opportunities grant.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "/home/cfog/ITAPS/repository/Papers/biblio/tstt"
options "acmtrans"

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Section
\start_of_appendix
A Simple Program Using the iMesh Component
\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "sec:iMesh-Interface-Syntax"

\end_inset


\end_layout

\begin_layout Plain Layout
As a simple example of usage of the iMesh component, including language
 differences, is illustrated by two versions of the same short program,
 one in C and the other in Fortran.
\end_layout

\begin_layout Subsection*
C
\begin_inset space ~
\end_inset

Version 
\end_layout

\begin_layout Plain Layout
In this version, note that string arguments (see lines 25 and 31) each have
 an argument at the end of the call list indicating the string length, for
 compatibility with Fortran string calling conventions.
\end_layout

\begin_layout LyX-Code

\size footnotesize
 1 /** FindConnect: Interacting with iMesh
\end_layout

\begin_layout LyX-Code

\size footnotesize
 2  * 
\end_layout

\begin_layout LyX-Code

\size footnotesize
 3  * This program shows how to get information about 
\end_layout

\begin_layout LyX-Code

\size footnotesize
 4  * a mesh, by getting connectivity two different 
\end_layout

\begin_layout LyX-Code

\size footnotesize
 5  * ways (as connectivity and as adjacent 0-dimensional 
\end_layout

\begin_layout LyX-Code

\size footnotesize
 6  * entities).
\end_layout

\begin_layout LyX-Code

\size footnotesize
 7  *
\end_layout

\begin_layout LyX-Code

\size footnotesize
 8  * Usage: FindConnect
\end_layout

\begin_layout LyX-Code

\size footnotesize
 9  *
\end_layout

\begin_layout LyX-Code

\size footnotesize
10  */
\end_layout

\begin_layout LyX-Code

\size footnotesize
11 #include <stdio.h>
\end_layout

\begin_layout LyX-Code

\size footnotesize
12 #include "iMesh.h"
\end_layout

\begin_layout LyX-Code

\size footnotesize
13 int main( int argc, char *argv[] )
\end_layout

\begin_layout LyX-Code

\size footnotesize
14 {
\end_layout

\begin_layout LyX-Code

\size footnotesize
15   int i, ierr;
\end_layout

\begin_layout LyX-Code

\size footnotesize
16   iMesh_Instance mesh;
\end_layout

\begin_layout LyX-Code

\size footnotesize
17   iBase_EntityHandle *ents, *verts, *allverts;
\end_layout

\begin_layout LyX-Code

\size footnotesize
18   int ents_alloc = 0, ents_size;
\end_layout

\begin_layout LyX-Code

\size footnotesize
19   int verts_alloc = 0, verts_size;
\end_layout

\begin_layout LyX-Code

\size footnotesize
20   int allverts_alloc = 0, allverts_size;
\end_layout

\begin_layout LyX-Code

\size footnotesize
21   int *offsets, offsets_alloc = 0, offsets_size;
\end_layout

\begin_layout LyX-Code

\size footnotesize
22   int vert_uses = 0;
\end_layout

\begin_layout LyX-Code

\size footnotesize
23   
\end_layout

\begin_layout LyX-Code

\size footnotesize
24   /* create the Mesh instance */
\end_layout

\begin_layout LyX-Code

\size footnotesize
25   iMesh_newMesh("", &mesh, &ierr, 0);
\end_layout

\begin_layout LyX-Code

\size footnotesize
26   
\end_layout

\begin_layout LyX-Code

\size footnotesize
27   /* Identify the root set */
\end_layout

\begin_layout LyX-Code

\size footnotesize
28   iBase_EntitySetHandle root_set;
\end_layout

\begin_layout LyX-Code

\size footnotesize
29   iMesh_getRootSet(mesh, &root_set, &ierr);
\end_layout

\begin_layout LyX-Code

\size footnotesize
30   /* load the mesh */
\end_layout

\begin_layout LyX-Code

\size footnotesize
31   iMesh_load(mesh, root_set, "125hex.vtk", "", &ierr, 10, 0);
\end_layout

\begin_layout LyX-Code

\size footnotesize
32   /* get all 3d elements */
\end_layout

\begin_layout LyX-Code

\size footnotesize
33   iMesh_getEntities(mesh, root_set, iBase_REGION, iMesh_ALL_TOPOLOGIES,
\end_layout

\begin_layout LyX-Code

\size footnotesize
34                     &ents, &ents_alloc, &ents_size, &ierr);
\end_layout

\begin_layout LyX-Code

\size footnotesize
35   /* iterate through them; */
\end_layout

\begin_layout LyX-Code

\size footnotesize
36   for (i = 0; i < ents_size; i++) {
\end_layout

\begin_layout LyX-Code

\size footnotesize
37     /* get connectivity */
\end_layout

\begin_layout LyX-Code

\size footnotesize
38     verts_alloc = 0;
\end_layout

\begin_layout LyX-Code

\size footnotesize
39     iMesh_getEntAdj(mesh, ents[i], iBase_VERTEX,
\end_layout

\begin_layout LyX-Code

\size footnotesize
40                     &verts, &verts_alloc, &verts_size,
\end_layout

\begin_layout LyX-Code

\size footnotesize
41                     &ierr);
\end_layout

\begin_layout LyX-Code

\size footnotesize
42     /* sum number of vertex uses */
\end_layout

\begin_layout LyX-Code

\size footnotesize
43     vert_uses += verts_size;
\end_layout

\begin_layout LyX-Code

\size footnotesize
44     free(verts);
\end_layout

\begin_layout LyX-Code

\size footnotesize
45   }
\end_layout

\begin_layout LyX-Code

\size footnotesize
46   /* now get adjacencies in one big block */
\end_layout

\begin_layout LyX-Code

\size footnotesize
47   iMesh_getEntArrAdj(mesh, ents, ents_size, iBase_VERTEX,
\end_layout

\begin_layout LyX-Code

\size footnotesize
48                      &allverts, &allverts_alloc, &allverts_size,
\end_layout

\begin_layout LyX-Code

\size footnotesize
49                      &offsets, &offsets_alloc, &offsets_size,
\end_layout

\begin_layout LyX-Code

\size footnotesize
50                      &ierr);
\end_layout

\begin_layout LyX-Code

\size footnotesize
51  
\end_layout

\begin_layout LyX-Code

\size footnotesize
52   /* compare results of two calling methods */
\end_layout

\begin_layout LyX-Code

\size footnotesize
53   if (allverts_size != vert_uses)
\end_layout

\begin_layout LyX-Code

\size footnotesize
54     puts("Sizes didn't agree");
\end_layout

\begin_layout LyX-Code

\size footnotesize
55   else 
\end_layout

\begin_layout LyX-Code

\size footnotesize
56     puts("Sizes did agree");
\end_layout

\begin_layout LyX-Code

\size footnotesize
57  
\end_layout

\begin_layout LyX-Code

\size footnotesize
58   return 0;
\end_layout

\begin_layout LyX-Code

\size footnotesize
59 }
\end_layout

\begin_layout Subsection*
Fortran
\begin_inset space ~
\end_inset

Version (32 bit compiler) 
\end_layout

\begin_layout Plain Layout
In this version, note particularly the use of Cray pointer and call-by-value
 extensions, both ubiquitous features of Fortran77 compilers, even though
 not mandated by the language standard.
\end_layout

\begin_layout LyX-Code

\size footnotesize
 1 c FindConnect: Interacting with iMesh
\end_layout

\begin_layout LyX-Code

\size footnotesize
 2 c 
\end_layout

\begin_layout LyX-Code

\size footnotesize
 3 c This program shows how to get more information about a mesh, by
\end_layout

\begin_layout LyX-Code

\size footnotesize
 4 c getting connectivity two different ways (as connectivity and as
\end_layout

\begin_layout LyX-Code

\size footnotesize
 5 c adjacent 0-dimensional entities).
\end_layout

\begin_layout LyX-Code

\size footnotesize
 6 c Usage: FindConnect
\end_layout

\begin_layout LyX-Code

\size footnotesize
 7       program findconnect
\end_layout

\begin_layout LyX-Code

\size footnotesize
 8 #include "iMesh_f.h"
\end_layout

\begin_layout LyX-Code

\size footnotesize
 9 c declarations
\end_layout

\begin_layout LyX-Code

\size footnotesize
10       iMesh_Instance mesh
\end_layout

\begin_layout LyX-Code

\size footnotesize
11       iBase_EntitySetHandle root_set
\end_layout

\begin_layout LyX-Code

\size footnotesize
12       integer ents
\end_layout

\begin_layout LyX-Code

\size footnotesize
13       integer rpverts, rpallverts, ipoffsets
\end_layout

\begin_layout LyX-Code

\size footnotesize
14       pointer (rpents, ents(0:*))
\end_layout

\begin_layout LyX-Code

\size footnotesize
15       pointer (rpverts, verts(0:*))
\end_layout

\begin_layout LyX-Code

\size footnotesize
16       pointer (rpallverts, allverts(0:*))
\end_layout

\begin_layout LyX-Code

\size footnotesize
17       pointer (ipoffsets, ioffsets(0,*))
\end_layout

\begin_layout LyX-Code

\size footnotesize
18       integer ierr, ents_alloc, ents_size
\end_layout

\begin_layout LyX-Code

\size footnotesize
19       integer iverts_alloc, iverts_size
\end_layout

\begin_layout LyX-Code

\size footnotesize
20       integer allverts_alloc, allverts_size
\end_layout

\begin_layout LyX-Code

\size footnotesize
21       integer offsets_alloc, offsets_size
\end_layout

\begin_layout LyX-Code

\size footnotesize
22 c create the Mesh instance
\end_layout

\begin_layout LyX-Code

\size footnotesize
23       call iMesh_newMesh("", mesh, ierr)
\end_layout

\begin_layout LyX-Code

\size footnotesize
24 c identify the root set
\end_layout

\begin_layout LyX-Code

\size footnotesize
25       call iMesh_getRootSet(%VAL(mesh), root_set, ierr)
\end_layout

\begin_layout LyX-Code

\size footnotesize
26 c load the mesh
\end_layout

\begin_layout LyX-Code

\size footnotesize
27       call iMesh_load(%VAL(mesh), %VAL(root_set), "125hex.vtk", "",
\end_layout

\begin_layout LyX-Code

\size footnotesize
28      1     ierr)
\end_layout

\begin_layout LyX-Code

\size footnotesize
29 c get all 3d elements
\end_layout

\begin_layout LyX-Code

\size footnotesize
30       ents_alloc = 0
\end_layout

\begin_layout LyX-Code

\size footnotesize
31       call iMesh_getEntities(%VAL(mesh), %VAL(root_set),
\end_layout

\begin_layout LyX-Code

\size footnotesize
32      1     %VAL(iBase_REGION), %VAL(iMesh_ALL_TOPOLOGIES), rpents,
\end_layout

\begin_layout LyX-Code

\size footnotesize
33      1     ents_alloc, ents_size, ierr)
\end_layout

\begin_layout LyX-Code

\size footnotesize
34       ivert_uses = 0
\end_layout

\begin_layout LyX-Code

\size footnotesize
35 c iterate through them; 
\end_layout

\begin_layout LyX-Code

\size footnotesize
36       do i = 0, ents_size-1
\end_layout

\begin_layout LyX-Code

\size footnotesize
37 c get connectivity
\end_layout

\begin_layout LyX-Code

\size footnotesize
38          iverts_alloc = 0
\end_layout

\begin_layout LyX-Code

\size footnotesize
39          idum = ents(i)
\end_layout

\begin_layout LyX-Code

\size footnotesize
40          call iMesh_getEntAdj(%VAL(mesh), %VAL(idum), 
\end_layout

\begin_layout LyX-Code

\size footnotesize
41      1        %VAL(iBase_VERTEX), rpverts, iverts_alloc, iverts_size,
\end_layout

\begin_layout LyX-Code

\size footnotesize
42      1        ierr)
\end_layout

\begin_layout LyX-Code

\size footnotesize
43 c sum number of vertex uses
\end_layout

\begin_layout LyX-Code

\size footnotesize
44          ivert_uses = ivert_uses + iverts_size
\end_layout

\begin_layout LyX-Code

\size footnotesize
45          call free(rpverts)
\end_layout

\begin_layout LyX-Code

\size footnotesize
46       end do
\end_layout

\begin_layout LyX-Code

\size footnotesize
47 c now get adjacencies in one big block
\end_layout

\begin_layout LyX-Code

\size footnotesize
48       allverts_alloc = 0
\end_layout

\begin_layout LyX-Code

\size footnotesize
49       offsets_alloc = 0
\end_layout

\begin_layout LyX-Code

\size footnotesize
50       call iMesh_getEntArrAdj(%VAL(mesh), ents, 
\end_layout

\begin_layout LyX-Code

\size footnotesize
51      1     %VAL(ents_size), %VAL(iBase_VERTEX), rpallverts, 
\end_layout

\begin_layout LyX-Code

\size footnotesize
52      1     allverts_alloc, allverts_size, ipoffsets, offsets_alloc, 
\end_layout

\begin_layout LyX-Code

\size footnotesize
53      1     offsets_size, ierr)
\end_layout

\begin_layout LyX-Code

\size footnotesize
54       call free(rpallverts);
\end_layout

\begin_layout LyX-Code

\size footnotesize
55       call free(ipoffsets);
\end_layout

\begin_layout LyX-Code

\size footnotesize
56       call free(rpents);
\end_layout

\begin_layout LyX-Code

\size footnotesize
57 c compare results of two calling methods
\end_layout

\begin_layout LyX-Code

\size footnotesize
58       if (allverts_size .ne.
 ivert_uses) then
\end_layout

\begin_layout LyX-Code

\size footnotesize
59          write(*,'("Sizes did not agree!")')
\end_layout

\begin_layout LyX-Code

\size footnotesize
60       else 
\end_layout

\begin_layout LyX-Code

\size footnotesize
61          write(*,'("Sizes did agree!")')
\end_layout

\begin_layout LyX-Code

\size footnotesize
62       endif
\end_layout

\begin_layout LyX-Code

\size footnotesize
63       call iMesh_dtor(%VAL(mesh), ierr)
\end_layout

\begin_layout LyX-Code

\size footnotesize
64       end
\end_layout

\begin_layout Subsection
Building iMesh Executables
\end_layout

\begin_layout Plain Layout
Building an iMesh executable requires that the compiler be able to find
 the iMesh header files (iMesh.h and iBase.h, or their Fortran counterparts)
 and that the linker be able to find a library containing the iMesh implementati
on.
 By convention, iMesh implementations contain a makefile snippet that defines
 a standard set of variables; an application's makefile then includes this
 snippet, greatly simplifying the build process.
 The makefile for building the two example programs above is:
\end_layout

\begin_layout LyX-Code

\size footnotesize
 1 include /path/to/iMesh/iMesh-Defs.inc
\end_layout

\begin_layout LyX-Code

\size footnotesize
 2
\end_layout

\begin_layout LyX-Code

\size footnotesize
 3 FC = gfortran -fcray-pointer -m32
\end_layout

\begin_layout LyX-Code

\size footnotesize
 4 CXX = g++
\end_layout

\begin_layout LyX-Code

\size footnotesize
 5 CC = gcc
\end_layout

\begin_layout LyX-Code

\size footnotesize
 6
\end_layout

\begin_layout LyX-Code

\size footnotesize
 7 FindConnectC: FindConnectC.o
\end_layout

\begin_layout LyX-Code

\size footnotesize
 8         $(CXX)  $(CXXFLAGS) -o $@ FindConnectC.o ${IMESH_LIBS} 
\end_layout

\begin_layout LyX-Code

\size footnotesize
 9 
\end_layout

\begin_layout LyX-Code

\size footnotesize
10 FindConnectF: FindConnectF.o
\end_layout

\begin_layout LyX-Code

\size footnotesize
11         $(CXX) -m32 -lgfortran -lgfortranbegin -o $@ 
\backslash

\end_layout

\begin_layout LyX-Code

\size footnotesize
                 FindConnectF.o ${IMESH_LIBS}
\end_layout

\begin_layout LyX-Code

\size footnotesize
12 
\end_layout

\begin_layout LyX-Code

\size footnotesize
13 .c.o:
\end_layout

\begin_layout LyX-Code

\size footnotesize
14         $(CC) -c $(CFLAGS) $(IMESH_INCLUDES) $<
\end_layout

\begin_layout LyX-Code

\size footnotesize
15 
\end_layout

\begin_layout LyX-Code

\size footnotesize
16 .F.o:
\end_layout

\begin_layout LyX-Code

\size footnotesize
17         ${FC} -c ${FFLAGS} ${IMESH_INCLUDES} $<
\end_layout

\begin_layout Plain Layout
Note that both executables are linked using the C++ linker to accommodate
 implementation libraries written in C++.
 The make variables 
\family typewriter
IMESH_INCLUDES
\family default
 (used in lines 14 and 17) and 
\family typewriter
IMESH_LIBS
\family default
 (using in lines 8 and 11) are defined in 
\family typewriter
/path/to/iMesh/iMesh-Defs.inc
\family default
; these variables are of course implementation-dependent.
 An additional useful variable defined by convention in this file is 
\family typewriter
IMESH_LIB_FILES
\family default
, which identifies iMesh implementation library files, so that these can
 be used as dependencies in makefile targets.
 
\end_layout

\end_inset


\end_layout

\end_body
\end_document
