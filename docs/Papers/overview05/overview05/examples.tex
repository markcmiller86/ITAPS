\appendix
\section[Usage Examples]{Elementary Examples of ITAPS Mesh Interface
  Usage}\label{sec:usage-examples}

This appendix presents very simple examples illustrating usage of the
ITAPS mesh interface.  These examples are meant to be illustrative
rather than exhaustive; much of the functionality of the mesh interface
is not showcased here.  The examples are written as stand-alone programs
that can be compiled and run with any ITAPS-compliant mesh database.

We note that the interface examples described here were developed
during the first round of SciDAC funding under the predecessor of the
ITAPS center, the Terascale Simulation Tools and Technologies (TSTT)
center.  With the advent of the SciDAC-2 program, the center was
renamed to ITAPS, but the team, philosophy and interface definition
efforts remain largely the same.  In the examples given here,
each interface is in the ITAPS namespace to avoid potential function
definition collisions.  The ``base'' functionality described in
Section 3.1, which includes tags, sets, and error handling is in the
iBase interface; the mesh functionality described in Section 3.2 is in
the iMesh interface.  

Full SIDL descriptions of the interfaces are available at
http://www.itaps-scidac.org/ under the Software link.  For those interested
in providing feedback on the interface definitions or participating in the
interface definition activity, please contact the ITAPS management team
at itaps-mgmt@lists.llnl.gov.

\subsection{Language Interoperability}

The ITAPS interface is designed to be not only data-structure neutral,
but also programming language neutral. That is, a mesh server can be
written in one language and client code in another. The ITAPS interface
is specified using an interface description language (SIDL), and
translated into language-specific interfaces through a tool called
Babel.\cite{babel,babel:site04} Babel also generates glue code that
mediates all inter-language issues, including function name mangling and
passage of string and array arguments.  As an example of how this works
in practice, consider the case of a request for mesh adjacency
information. An application code using the ITAPS interface makes an
adjacency request by calling a \emph{stub} function (auto-generated by
Babel) in the language of the application.  This function re-packages
function arguments and calls an \emph{internal object representation}
function (auto-generated by Babel, in C), which again repackages
arguments and calls a \emph{skeleton} function (auto-generated by Babel)
in the language of the server. This function, finally, calls the server
implementation of the original SIDL function. This approach eliminates
all language-specific issues, including name mangling schemes and the
treatment of strings and arrays, including dynamic array handling.  In
exchange, four versions of each SIDL function exist (three of which are
auto-generated), and a call from client code must pass through all these
layers. Not surprisingly, this complexity in call sequences can have a
significant impact on application efficiency.

As an example of the function signatures that Babel creates in various
languages, let us examine the mesh interface function for retrieving the
entities adjacent to a single entity.  The SIDL declaration for this
function is

\begin{verbatim}
package iMesh{
...
void getEntAdj(in opaque entity_handle,
               in EntityType entity_type_requested,
               inout array<opaque> adj_entity_handles,
               out int adj_entity_handles_size) throws iBase.Error;
}
\end{verbatim}

Clients call this function in different ways depending on the language
in which the client is written.  The C++ binding most nearly
duplicates the SIDL function declaration;
 
\begin{verbatim}
void iMesh::getEntAdj(void* entity_handle,
                      ::iMesh::EntityType entity_type_requested,
                      ::sidl::array<void*>& adj_entity_handles,
                      int32_t& adj_entity_handles_size)
    throw (::iBase::Error);
\end{verbatim}

In the C binding, the function name has been decorated to prevent naming
clashes between SIDL interfaces, and two arguments have been added.  One
of these ({\tt self}) is a handle for the iMesh data and the other ({\tt
\_ex}) is used to return exceptions. 
\begin{verbatim}
void iMesh_Entity_getEntAdj(iMesh_Entity self,
                            void* entity_handle,
                            enum iMesh_EntityType__enum entity_type_requested,
                            struct sidl_opaque__array** adj_entity_handles,
                            int32_t* adj_entity_handles_size,
                            sidl_BaseInterface *_ex);
\end{verbatim}

In Fortran77, all arguments are passed by address, and SIDL uses 64-bit
integers when passing handles.  Like the C binding, arguments have been
added for the iMesh data and exception return.
\begin{verbatim}
      subroutine iMesh_Entity_getEntAdj_f(self, entity_handle,
     &     entity_type_requested, adj_entity_handles,
     &     adj_entity_handles_size, exception)
      integer*8 self, entity_handle
      integer*4 entity_type_requested
      integer*8 adj_entity_handles
      integer*4 adj_entity_handles_size
      integer*8 exception
\end{verbatim}

Finally, the Fortran90 API is organized into modules and takes advantage
of user-defined types, in a manner quite similar to the C API.
\begin{verbatim}
recursive subroutine getEntAdj_s(self, entity_handle, entity_type_requested, &
    adj_entity_handles, adj_entity_handles_size, exception)
  implicit none
  type(iMesh_Entity_t) , intent(in) :: self
  integer (selected_int_kind(18)) , intent(in) :: entity_handle
  integer (selected_int_kind(9)) , intent(in) :: entity_type_requested
  type(sidl_opaque_1d) , intent(inout) :: adj_entity_handles
  integer (selected_int_kind(9)) , intent(out) :: adj_entity_handles_size
  type(sidl_BaseInterface_t) , intent(out) :: exception
\end{verbatim}


\subsection{Mesh Adjacency Example}

This example shows two ways in which entity adjacencies can be retrieved
using the ITAPS iMesh interface.  This example is written in C++; because the
ITAPS team uses Babel for interlanguage calls, the underlying 
implementation could be in any Babel-supported language.  

\begin{algorithm}
\begin{verbatim}
 1 #include <iostream>
 2 #include "iMesh.hh"
 3
 4 typedef void* EntityHandle;
 5 typedef void* EntitySetHandle;
 6 typedef void* IteratorHandle;
 7 int main( int argc, char *argv[] )
 8 {
 9   iMesh::Mesh mesh = iMesh::Factory::newMesh("");
10   std::string filename = argv[1];
11   EntitySetHandle rootSet = mesh.getRootSet();
12   mesh.load(rootSet, filename);
13
14   int vert_uses = 0;   // Iterate to access adjacencies
15   iMesh::Entity mesh_ent = mesh;
16   IteratorHandle iter;
17   mesh_ent.initEntIter(rootSet, iMesh::EntityType_REGION, 
18                        iMesh::EntityTopology_ALL_TOPOLOGIES, iter);
19   EntityHandle ent;
20   bool moreData = mesh_ent.getNextEntIter(iter, ent);
21   while (moreData) {
22     sidl::array<EntityHandle> verts;
23     int verts_size;
24     mesh_ent.getEntAdj(ent, iMesh::EntityType_VERTEX,
25                        verts, verts_size);
26     vert_uses += verts_size;
27     moreData = mesh_ent.getNextEntIter(iter, ent);
28   }
29
30   sidl::array<EntityHandle> ents;   // Block Retrieval
31   int ents_size;
32   mesh.getEntities(rootSet, iMesh::EntityType_REGION, 
33                    iMesh::EntityTopology_ALL_TOPOLOGIES,
34                    ents, ents_size);
35   sidl::array<EntityHandle> allverts;
36   sidl::array<int> offsets;
37   int allverts_size, offsets_size;
38   iMesh::Arr mesh_arr = mesh;
39   mesh_arr.getEntArrAdj(ents, ents_size, iMesh::EntityType_VERTEX,
40                         allverts, allverts_size,
41                         offsets, offsets_size);
42   std::cout << "Sizes did ";
43   if (allverts_size != vert_uses) std::cout << "not";
44   std::cout << " agree!" << std::endl;
45   return true;
46 }
\end{verbatim}
\caption{Example of adjacency retrieval using the ITAPS mesh interface.}\label{ex:adjacency}
\end{algorithm}

In line 9, a new mesh instance is created, using a factory.
This factory is implementation-specific, but its {\em interface} is not,
freeing an application from any compile-time dependence on a single
implementation.  The ITAPS implementation is supplied at link time or,
with dynamically-loaded libraries, at run time.  In lines 10--12, mesh
data is read from a file into the root set of the mesh.

Lines 14--28 iterate through all the three-dimensional entities
(regions) of the mesh, counting their total number of vertices.  The
iteration is controlled by an entity-by-entity iterator, initialized in
line 17.  Note that this iterator is not defined as part of the
iMesh::Mesh base interface but in a more specialized interface,
iMesh::Entity; line 15 casts the Mesh object to Entity.\footnote{While
C++ could handle the relationships among interfaces using inheritance,
not all languages can, so Babel does not use this idiom in C++ either.}
In line 19, the iterator provides both a boolean value indicating
whether more data is available and the handle of the next available
entity if there is one.  This syntax is admittedly somewhat awkward, but
if a mesh is modified, it is impossible in general to be certain whether
there will be another entity until one tries to retrieve the next one.
Line 24 is the heart of the adjacency retrieval loop, returning an array
of all vertices adjacent to the current region in the iteration.

Lines 30--41 illustrate block retrieval of entity adjacency information.
Line 32 first retrieves all regions in the mesh.  Then, in line 39, all
vertices adjacent to the entities whose handles are in {\tt ents} (i.e.,
all regions) are returned; the contents of {\tt offsets} identifies, for
each {\tt ent}, where its list of vertices begins in {\tt allverts}.

Finally, lines 42--44 report whether the total numbers of adjacent
vertices retrieved by these alternate approaches are consistent.

\subsection{Set and Tag Example}

This example shows simple retrieval of entity sets and identification of
tags attached to those sets.  Again, the underlying ITAPS
implementation could be in any Babel-supported language.  

\begin{algorithm}
\begin{verbatim}
 1 #include <iostream>
 2 #include <set>
 3 #include "iMesh.hh"
 4 #include "iBase.hh"
 5 
 6 typedef void* EntityHandle;
 7 typedef void* EntitySetHandle;
 8 typedef void* TagHandle;
 9 
10 int main( int argc, char *argv[] )
11 {
12   std::string filename = argv[1];
13   iMesh::Mesh mesh = iMesh::Factory::newMesh("");
14   EntitySetHandle rootSet = mesh.getRootSet();
15   mesh.load(rootSet, filename);
16 
17   sidl::array<EntitySetHandle> sets;
18   int sets_size;
19   iBase::EntSet mesh_eset = mesh;
20   mesh_eset.getEntSets(rootSet, 1, sets, sets_size);
21 
22   iBase::SetTag mesh_stag = mesh;  //Retrieve set tag info
23   std::set<TagHandle> tag_handles;
24   for (int i = 0; i < sets_size; i++) {
25     sidl::array<TagHandle> tags;
26     int tags_size;
27     mesh_stag.getAllEntSetTags(sets[i], tags, tags_size);
28     for (int j = 0; j < tags_size; j++) {
29       tag_handles.insert(tags[j]);
30     }
31   }
32
33   for (std::set<TagHandle>::iterator sit = tag_handles.begin(); 
34        sit != tag_handles.end(); sit++) {
35     std::string tag_name = mesh_stag.getTagName(*sit);
36     int tag_size = mesh_stag.getTagSizeBytes(*sit);
37     std::cout << "Tag name = '" << tag_name 
38               << "', size = " << tag_size << " bytes." << std::endl;
39   }
40   return true;
41 }
\end{verbatim}
\caption{Example of entity set and tag retrieval using the ITAPS mesh interface.}\label{ex:sets-tags}
\end{algorithm}
 
After reading a mesh as in the previous example, all the entity sets
defined for the mesh are retrieved (line 20).

Lines 22--31 retrieve tag information for the sets.  Specifically, line
27 retrieves all tags attached to a particular entity set, and the loop
from lines 28--30 populates a standard template library {\tt set} of tag
handles.

Finally, the loop from lines 33--39 output information about each tag
found, in order of increasing tag handle.  For each tag handle, the name
of the tag (retrieved in line 35) and its size in bytes (retrieved in
line 36) are output.


