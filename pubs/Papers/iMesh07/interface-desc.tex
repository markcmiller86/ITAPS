\section{Interface Description\label{sec:Interface}}

We have defined interfaces for a variety of commonly needed and supported
functionalities for mesh and entity query, mesh modification, entity
set operations, and tags. In this section we describe the functionality
available through the iMesh interface, including semantic descriptions
of the function calls in the interface.%
\footnote{Note that these descriptions do not include detailed syntax, which
can be found in the interface user guide\cite{TSTTB-UG,TSTTM-UG}.%
} For compatibility with the Fortran convention that functions returning
values do not modify their arguments, no ITAPS functions return values.
That is, all ITAPS functions are C void functions or Fortran subroutines.
In the abbreviated argument lists given in the tables below, string
arguments have an accompanying argument giving their length; this
is included for Fortran compatibility, and the string length arguments
are added at the end of the argument list in the order the strings
appear. Also, each array argument has an accompanying integer telling
how many entries in the array are in use; output arrays also have
an integer argument specifying their total allocated size. In addition
to the arguments listed, each function also has a mesh instance as
its first argument (analogous to the hidden \texttt{this} argument
in C++ member functions) and returns an integer status value in an
argument. For listings of allowable values of all ITAPS enumerated
data types and a concrete example of the full call sequence for functions
with arrays and strings, see Appendix~\ref{app:ITAPS-enum}.


\subsection{Global Queries\label{sub:Mesh-Interface}}

Global query functions can be categorized into two groups: 1) \emph{database
functions}, that manipulate the properties of the database as a whole
and 2) \emph{set query functions}, that query the contents of entity
sets as a whole; these functions require an entity set argument, which
may be the root set as a special case. These functions are summarized
in Table~\ref{table:Mesh-Int}.

%
\begin{table}

\caption{Functions for Global Queries}

\label{table:Mesh-Int} \begin{tabular}{|p{1.25in}|p{223pt}|}
\hline 
{\small Function}&
{\small Description}\tabularnewline
\hline
\hline 
{\small iMesh\_newMesh}&
{\small Creates a new, empty mesh instance}\tabularnewline
\hline 
{\small iMesh\_dtor}&
{\small Destroys a mesh instance}\tabularnewline
\hline 
{\small iMesh\_load}&
{\small Loads mesh data from file into entity set}\tabularnewline
\hline 
{\small iMesh\_save}&
{\small Saves data from entity set to file}\tabularnewline
\hline 
{\small iMesh\_getRootSet}&
{\small Returns handle for the root set}\tabularnewline
\hline 
{\small iMesh\_getGeometricDim}&
{\small Returns geometric dimension of mesh}\tabularnewline
\hline 
{\small iMesh\_getDfltStorage}&
{\small Tells whether implementation prefers blocked or interleaved
coordinate data}\tabularnewline
\hline 
{\small iMesh\_getAdjTable}&
{\small Returns table indicating availability and cost of entity adjacency
data}\tabularnewline
\hline 
{\small iMesh\_areEHValid}&
{\small Returns true if EH remain unchanged since last user-requested
status reset}\tabularnewline
\hline
\hline 
{\small iMesh\_getNumOfType}&
{\small Returns number of entities of type in ES}\tabularnewline
\hline 
{\small iMesh\_getNumOfTopo}&
{\small Returns number of entities of topo in ES}\tabularnewline
\hline 
{\small iMesh\_getAllVtxCoords}&
{\small Returns coords of all vertices in the set and all vertices
on the closure of higher-dimensional entities in the set; storage
order can be user-specified}\tabularnewline
\hline 
{\small iMesh\_getEntities}&
{\small Returns all entities in ES of the given type and topology}\tabularnewline
\hline 
{\small iMesh\_getAdjEntities}&
{\small For all entities of given type and topology in ES, return
adjacent entities of adj\_type}\tabularnewline
\hline 
{\small iMesh\_getAllVtxCoords}&
{\small For all vertices, return coords; storage order can be user-specified.}\tabularnewline
\hline 
{\small iMesh\_getVtxArrCoords}&
{\small For all input vertex handles, return coords; storage order
can be user-specified.}\tabularnewline
\hline 
{\small iMesh\_getVtxCoordIndex}&
{\small For all entities of given type and topology, find adjacent
entities of adj\_Type, and return the coordinate indices for their
vertices. Vertex ordering matches that in getAllVtxCoords.}\tabularnewline
\hline
\end{tabular}
\end{table}


Database functions include functions to create and destroy mesh instances;
note that the create function only sets up data structures for the
mesh instance, without supplying any mesh data. The load and save
functions read and write mesh information from files; file format
and read/write options are implementation dependent. As mesh data
is loaded, entities are stored in the root set, and can optionally
be placed into a subsidiary entity set as well. iMesh implementations
must be able to provide coordinate information in both blocked (xxx...yyy...zzz...)
and interleaved (xyzxyzxyz...) formats; an application can query the
implementation to determine the implementation's preferred storage
order. Also, implementations must provide information about the availability
and relative cost of computing adjacencies between entities of different
types. Finally, each instance of the interface must provide a handle
for the root set.

Set query functions allow an application to retrieve information about
entities in a set. The entity set may be the root set, which will
return selected contents of the entire database, or may be any subsidiary
entity set. For example, functions exist to request the number of
mesh entities of a given type or topology; the types and topologies
are defined as enumerations. Applications can request handles for
all entities of a given type or topology or handles for entities of
a given type adjacent to all entities of a given type or topology.
Also, vertex coordinates are available in either blocked or interleaved
order. Coordinate requests can be made for all vertices or for the
vertex handles returned by an adjacency call. Finally, indices into
the global vertex coordinate array can be obtained for both entity
and adjacent entity requests.


\subsection{Entity- and Array-Based Query\label{sub:Ent-Interface}}

%
\begin{table}

\caption{Functions for Single Entity Queries}

\label{table:Entity} \begin{tabular}{|p{1.25in}|p{223pt}|}
\hline 
{\small Function}&
{\small Description}\tabularnewline
\hline
\hline 
{\small iMesh\_initEntIter}&
{\small Create an iterator to traverse entities of type and topo in
ES; return true if any entities exist}\tabularnewline
\hline 
{\small iMesh\_getNextEntIter}&
{\small Return true and a handle to next entity if there is one; false
otherwise}\tabularnewline
\hline 
{\small iMesh\_resetEntIter}&
{\small Reset iterator to restart traverse from the first entity}\tabularnewline
\hline 
{\small iMesh\_endEntIter}&
{\small Destroy iterator}\tabularnewline
\hline
\hline 
{\small iMesh\_getType}&
{\small Return type of entity}\tabularnewline
\hline 
{\small iMesh\_getTopo}&
{\small Return topology of entity}\tabularnewline
\hline 
{\small iMesh\_getVtxCoord}&
{\small Return coordinates of a vertex}\tabularnewline
\hline 
{\small iMesh\_getEntAdj}&
{\small Return entities of given type adjacent to EH}\tabularnewline
\hline
\end{tabular}
\end{table}


%
\begin{table}

\caption{Functions for Block Entity Queries}

\label{table:EntArr} \begin{tabular}{|p{1.25in}|p{223pt}|}
\hline 
{\small Function}&
{\small Description}\tabularnewline
\hline
\hline 
{\small iMesh\_initEntArrIter}&
{\small Create a block iterator to traverse entities of type and topo
in ES}\tabularnewline
\hline 
{\small iMesh\_getNextEntArrIter}&
{\small Return true and a block of handles if there are any; false
otherwise}\tabularnewline
\hline 
{\small iMesh\_resetEntArrIter}&
{\small Reset block iterator to restart traverse from the first entity}\tabularnewline
\hline 
{\small iMesh\_endEntArrIter}&
{\small Destroy block iterator}\tabularnewline
\hline
\hline 
{\small iMesh\_getEntArrType}&
{\small Return type of each entity}\tabularnewline
\hline 
{\small iMesh\_getEntArrTopo}&
{\small Return topology of each entity}\tabularnewline
\hline 
{\small iMesh\_getEntArrAdj}&
{\small Return entities of type adjacent to each EH}\tabularnewline
\hline
\end{tabular}
\end{table}


The global queries described in the previous section are used to retrieve
information about all entities in an entity set. While this is certainly
a practical alternative for some types of problems and for small problem
size, larger problems or situations involving mesh modification require
access to single entities or to blocks of entities. The iMesh interface
supports traversal and query functions for single entities and for
blocks of entities; the query functions supported are entity type
and topology, vertex coordinates, and entity adjacencies. Tables~\ref{table:Entity}
and~\ref{table:EntArr} summarize these functions.


\subsection{Mesh Modification\label{sub:Mesh-Modification}}

The iMesh interface supports mesh modification by providing a minimal
set of operators for low-level modification; both single entity (see
Table~\ref{table:Modify}) and block versions (see Table~\ref{table:ModArr})
of these operators are provided. High-level functionality, including
mesh generation, quality assessment, and validity checking, can in
principle be built from these operators, although in practice such
functionality is more likely to be provided using intermediate-level
services that perform complete unit operations, including vertex insertion
and deletion with topology updates, edge and face swapping, and smoothing.

%
\begin{table}

\caption{Functions for Single Entity Mesh Modification}

\label{table:Modify} \begin{tabular}{|p{1.25in}|p{223pt}|}
\hline 
{\small Function}&
{\small Description}\tabularnewline
\hline
\hline 
{\small iMesh\_createVtx}&
{\small Create vertex at given location}\tabularnewline
\hline 
{\small iMesh\_setVtxCoords}&
{\small Changes coordinates of existing vertex}\tabularnewline
\hline 
{\small iMesh\_createEnt}&
{\small Create entity of given topology from lower-dimensional entities;
return entity handle and creation status}\tabularnewline
\hline 
{\small iMesh\_deleteEnt}&
{\small Delete EH from the mesh}\tabularnewline
\hline
\end{tabular}
\end{table}


%
\begin{table}

\caption{Functions for Block Mesh Modification}

\label{table:ModArr} \begin{tabular}{|p{1.25in}|p{223pt}|}
\hline 
{\small Function}&
{\small Description}\tabularnewline
\hline
\hline 
{\small iMesh\_createVtxArr}&
{\small Create vertices at given location}\tabularnewline
\hline 
{\small iMesh\_setVtxArrCoords}&
{\small Changes coordinates of existing vertices}\tabularnewline
\hline 
{\small iMesh\_createEntArr}&
{\small Create entities of given topology from lower-dimensional entities;
return entity handle and status}\tabularnewline
\hline 
{\small iMesh\_deleteEntArr}&
{\small Delete each EH from the mesh}\tabularnewline
\hline
\end{tabular}
\end{table}


Geometry modification is achieved through functions that change vertex
locations. Vertex locations are set at creation, and can be changed
as required, for instance, by mesh smoothing or other node movement
algorithms.

Topology modification is achieved through the creation and deletion
of mesh entities. Creation of higher-dimensional entities requires
specification, in canonical order, of an appropriate collection of
lower-dimensional entities. For instance, a tetrahedron can be created
using four vertices, six edges or four faces, but not from combinations
of these. Upon creation, adjacency information properly connecting
the new entity to its components is set up by the implementation.
Some implementations may allow the creation of duplicate entities
(for example, two edges connecting the same two vertices), while others
will respond to such a creation request by returning a copy of the
already-existing entity.

Deletion of existing entities must always be done from highest to
lowest dimension, because the iMesh interface forbids the deletion
of an entity with existing upward adjacencies (for instance, an edge
that is still in use by one or more faces or regions).


\subsection{Entity Sets\label{sub:Entity-Set-Interface}}

The iMesh entity set interface is divided into three parts: basic
set functionality, hierarchical set relations, and set boolean operations.

%
\begin{table}

\caption{Functions for Basic Entity Set Functionality}

\label{table:EntSet} \begin{tabular}{|p{1.25in}|p{223pt}|}
\hline 
{\small Function}&
{\small Description}\tabularnewline
\hline
\hline 
{\small iMesh\_createEntSet}&
{\small Creates a new entity set (ordered and non-unique if isList
is true)}\tabularnewline
\hline 
{\small iMesh\_destroyEntSet}&
{\small Destroys existing entity set}\tabularnewline
\hline 
{\small iMesh\_isList}&
{\small Return true if the set is ordered and non-unique}\tabularnewline
\hline
\hline 
{\small iMesh\_getNumEntSets}&
{\small Returns number of entity sets contained in SH}\tabularnewline
\hline 
{\small iMesh\_getEntSets}&
{\small Returns entity sets contained in SH}\tabularnewline
\hline 
{\small iMesh\_addEntSet}&
{\small Adds entity set SH1 as a member of SH2}\tabularnewline
\hline 
{\small iMesh\_rmvEntSet}&
{\small Removes entity set SH1 as a member of SH2}\tabularnewline
\hline 
{\small iMesh\_isEntSetContained}&
{\small Returns true if SH2 is a member of SH1}\tabularnewline
\hline
\hline 
{\small iMesh\_addEntToSet}&
{\small Add entity EH to set SH}\tabularnewline
\hline 
{\small iMesh\_rmvEntFromSet}&
{\small Remove entity EH from set SH}\tabularnewline
\hline 
{\small iMesh\_addEntArrToSet}&
{\small Add array of entities to set SH}\tabularnewline
\hline 
{\small iMesh\_rmvEntArrFromSet}&
{\small Remove array of entities from set SH}\tabularnewline
\hline 
{\small iMesh\_isEntContained}&
{\small Returns true if EH is a member of SH}\tabularnewline
\hline
\end{tabular}
\end{table}


Basic set functionality, summarized in Table~\ref{table:EntSet},
includes creating and destroying entity sets; adding and removing
entities and sets; and several entity set specific query functions.
%
\footnote{Note that the global mesh query functions (Section~\ref{sec:Interface}.\ref{sub:Mesh-Interface})
and traversal functions (Section~\ref{sec:Interface}.\ref{sub:Ent-Interface})
defined above can be used with the root set or any other entity set
as their first argument.%
} Entity sets can be either ordered and non-unique, or unordered and
unique; an ordered set guarantees that query results (including traversal)
will always be given in the order in which entities were added to
the set. The ordered/unordered status of an entity set must be specified
when the set is created and can be queried.

Entity sets are created empty. Entities can be added to or removed
from the set individually or in blocks; for ordered sets, the last
of a number of duplicate entries will be the first to be deleted.
Also, entity sets can be added to or removed from each other; note
that, because all sets are automatically contained in the root set
from creation, calls that would add or remove a set from the root
set are not permitted. An entity set can also be queried to determine
the number and handles of sets that it contains, and to determine
whether a given entity or set belongs to that set.

%
\begin{table}

\caption{Functions for Entity Set Relationships}

\label{table:SetRel} \begin{tabular}{|p{1.25in}|p{223pt}|}
\hline 
{\small Function}&
{\small Description}\tabularnewline
\hline
\hline 
{\small iMesh\_addPrntChld}&
{\small Create a parent (SH1) to child (SH2) relationship}\tabularnewline
\hline 
{\small iMesh\_rmvPrntChld}&
{\small Remove a parent (SH1) to child (SH2) relationship}\tabularnewline
\hline 
{\small iMesh\_isChildOf}&
{\small Return true if SH2 is a child of SH1}\tabularnewline
\hline 
{\small iMesh\_getNumChld}&
{\small Return number of children of SH}\tabularnewline
\hline 
{\small iMesh\_getChldn}&
{\small Return children of SH}\tabularnewline
\hline 
{\small iMesh\_getNumPrnt}&
{\small Return number of parents of SH}\tabularnewline
\hline 
{\small iMesh\_getPrnts}&
{\small Return parents of SH}\tabularnewline
\hline
\end{tabular}
\end{table}


Hierarchical relationships between entity sets are intended to describe,
for example, multilevel meshes and mesh refinement hierarchies. The
directional relationships implied here are labeled as parent-child
relationships in the iMesh interface. Functions are provided to add,
remove, count, and identify parents and children and to determine
if one set is a child of another; see Table~\ref{table:SetRel}.

%
\begin{table}

\caption{Functions for Entity Set Boolean Operations}

\label{table:SetBool} \begin{tabular}{|p{1.25in}|p{223pt}|}
\hline 
{\small Function}&
{\small Description}\tabularnewline
\hline
\hline 
{\small iMesh\_subtract}&
{\small Return set difference SH1-SH2 in SH}\tabularnewline
\hline 
{\small iMesh\_intersect}&
{\small Return set intersection of SH1 and SH2 in SH}\tabularnewline
\hline 
{\small iMesh\_unite}&
{\small Return set union of SH1 and SH2 in SH}\tabularnewline
\hline
\end{tabular}
\end{table}


Set boolean operations --- intersection, union, and subtraction ---
are also defined by the iMesh interface; these functions are summarized
in Table~\ref{table:SetBool}. The definitions are intended to be
compatible with their C++ standard template library (STL) counterparts,
both for semantic clarity and so that STL algorithms can be used by
implementations where appropriate. All set boolean operations apply
not only to \emph{entity} members of the set, but also to \emph{set}
members. Note that set hierarchical relationships are not included:
the set resulting from a set boolean operation on sets with hierarchical
relationships will \emph{not} have any hierarchical relationships
defined for it, regardless of the input data. For instance, if one
were to take the intersection of two directionally-coarsened meshes
(stored as sets) with the same parent mesh (also a set) in a multigrid
hierarchy, there is no reason to expect that the resulting set will
necessarily be placed in the multigrid hierarchy at all. On the other
hand, if both of those directionally-coarsened meshes contain a set
of boundary faces, then their intersection will contain that set as
well.

While set boolean operations are completely unambiguous for unordered
entity sets, ordered sets make things more complicated. For operations
in which one set is ordered and one unordered, the result set is unordered;
its contents are the same as if an unordered set were created with
the (unique) contents of the ordered set and the operation were then
performed. In the case of two ordered sets, the iMesh specification
follows the spirit of the STL definition, with complications related
to the possibility of multiple copies of a given entity handle in
each set. In the following discussion, assume that a given entity
handle appears $m$ times in the first set and $n$ times in the second
set.

\begin{itemize}
\item For intersection of two ordered sets, the output set will contain
the $\min\left(m,n\right)$ copies of the entity handle. These will
appear in the same order as in the first input set, with the first
copies of the handle surviving. For example, intersection of the two
sets $A=\textrm{\{$abacdbca$\}}$ and $B=\{ dadbac\}$ will result
in $A\bigcap B=\{ abacd\}$. 
\item Union of two ordered sets is easy: the output set is a concatenation
of the input sets: $A\bigcup B=\{ abacdbcadadbac\}$. 
\item Subtraction of two ordered sets results in a set containing $\min\left(m-n,0\right)$
copies of an entity handle. These will appear in the same order as
in the first input set, with the first copies of the handle surviving.
For example, $A-B=\{ abc\}$. 
\end{itemize}
Regardless of whether the entity members of an entity set are ordered
or unordered, the set members are always unordered and unique, with
correspondingly simple semantics for boolean operations.


\subsection{Tags\label{sub:Tag-Interface}}

%
\begin{table}

\caption{Basic Tag Functions}

\label{table:Tags} \begin{tabular}{|p{1.25in}|p{223pt}|}
\hline 
{\small Name}&
{\small Description}\tabularnewline
\hline
\hline 
{\small iMesh\_createTag}&
{\small Creates a new tag of the given type and number of values}\tabularnewline
\hline 
{\small iMesh\_destroyTag}&
{\small Destroys the tag if no entity is using it or if force is true}\tabularnewline
\hline
\hline 
{\small iMesh\_getTagName}&
{\small Returns tag ID string}\tabularnewline
\hline 
{\small iMesh\_getTagSizeValues}&
{\small Returns tag size in number of values}\tabularnewline
\hline 
{\small iMesh\_getTagSizeBytes}&
{\small Returns tag size in number of bytes}\tabularnewline
\hline 
{\small iMesh\_getTagHandle}&
{\small Return tag with given ID string, if it exists}\tabularnewline
\hline 
{\small iMesh\_getTagType}&
{\small Return data type of this tag}\tabularnewline
\hline
\hline 
{\small iMesh\_getAllTags}&
{\small Return handles of all tags associated with entity EH}\tabularnewline
\hline 
{\small iMesh\_getAllEntSetTags}&
{\small Return handles of all tags associated with entity set SH}\tabularnewline
\hline
\end{tabular}
\end{table}


Tags are used to associate application-dependent data with a mesh,
entity, or entity set. Basic tag functionality defined in the iMesh
interface is summarized in Table~\ref{table:Tags}, while functionality
for setting, getting, and removing tag data is summarized in Table~\ref{table:Tags2}.

When creating a tag, the application must provide its data type and
size, as well as a unique name. For generic tag data, the tag size
specifies how many bytes of data to store; for other cases, the size
tells how many values of that data type will be stored. The implementation
is expected to manage the memory needed to store tag data. The name
string and data size can be retrieved based on the tag's handle, and
the tag handle can be found from its name. Also, all tags associated
with a particular entity can be retrieved; this can be particularly
useful in saving or copying a mesh.

%
\begin{table}

\caption{Setting, Getting, and Removing Tag Data}

\label{table:Tags2} \begin{tabular}{|p{1.25in}|p{223pt}|}
\hline 
{\small Function}&
{\small Description}\tabularnewline
\hline
\hline 
{\small iMesh\_setData}&
{\small The value in tag TH for entity EH is set to the first tagValSize
bytes of the array\textless{}char\textgreater{} tagVal}\tabularnewline
\hline 
{\small iMesh\_setArrData}&
{\small The value in tag TH for entities in EHarray{[}i] is set using
data in the array\textless{}char\textgreater{} tagValArray and the
tag size}\tabularnewline
\hline 
{\small iMesh\_setEntSetData}&
{\small The value in tag TH for entity set SH is set to the first
tagValSize bytes of the array\textless{}char\textgreater{} tagVal}\tabularnewline
\hline 
{\small iMesh\_set{[}Int,Dbl,EH]Data}&
{\small The value in tag TH for entity EH is set to the int, double,
or entity handle in tagVal; array and entity set versions also exist.}\tabularnewline
\hline
\hline 
{\small iMesh\_getData}&
{\small Return the value of tag TH for entity EH}\tabularnewline
\hline 
{\small iMesh\_getArrData}&
{\small Retrieve the value of tag TH for all entities in EH array,
with data returned as an array of tagVal's}\tabularnewline
\hline 
{\small iMesh\_getEntSetData}&
{\small Return the value of tag TH for entity EH}\tabularnewline
\hline 
{\small iMesh\_get{[}Int,Dbl,EH]Data}&
{\small Return the value of tag TH for entity EH; array and entity
set versions also exist.}\tabularnewline
\hline
\hline 
{\small iMesh\_rmvTag}&
{\small Remove tag TH from entity EH}\tabularnewline
\hline 
{\small iMesh\_rmvArrTag}&
{\small Remove tag TH from all entities in EH array}\tabularnewline
\hline 
{\small iMesh\_rmvEntSetTag}&
{\small Remove tag TH from entity set SH}\tabularnewline
\hline
\end{tabular}
\end{table}


Initially, a tag is not associated with any entity or entity set,
and no tag values exist; association is made explicitly by setting
data for a tag-entity pair. Tag data can be set for single entities,
arrays of entities (each with its own value), or for entity sets.
In each of these cases, separate functions exist for setting generic
tag data and type-specific data. Analogous data retrieval functions
exist for each of these cases.

When an entity or set no longer needs to be associated with a tag
--- for instance, a vertex was tagged for smoothing and the smoothing
operation for that vertex is complete --- the tag can be removed from
that entity without affecting other entities associated with the tag.
When a tag is no longer needed at all --- for instance, when all vertices
have been smoothed --- the tag can be destroyed through one of two
variant mechanisms. First, an application can remove this tag from
all tagged entities, and then request destruction of the tag. Simpler
for the application is forced destruction, in which the tag is destroyed
even though the tag is still associated with mesh entities, and all
tag values and associations are deleted. Some implementations may
not support forced destruction.


\subsection{Error Handling\label{sub:Error-Handling}}

Like any API, the iMesh interface is vulnerable to errors, either
through incorrect input or through internal failure within an implementation.
For instance, it is an error for an application to request entities
with conflicting types and topologies. Also, an error in the implementation
occurs when memory for a new object cannot be allocated. The iMesh
error interface defines a number of standard error conditions which
could occur in iMesh functions, either because of illegal input or
internal implementation errors; each of these error conditions

%
\begin{table}

\caption{Error Handling Functionality}

\label{table:Error} \begin{tabular}{|p{1.25in}|p{223pt}|}
\hline 
{\small Name}&
{\small Description}\tabularnewline
\hline
\hline 
{\small iMesh\_getDescription}&
{\small Retrieves error description}\tabularnewline
\hline
\end{tabular}
\end{table}
