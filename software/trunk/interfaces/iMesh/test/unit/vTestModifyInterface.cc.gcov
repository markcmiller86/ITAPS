        -:    0:Source:vTestModifyInterface.cc
        -:    0:Programs:15
        -:    1:#include "iMesh_unitTest.hh"
        -:    2:
        -:    3:// If the expected number of entities is < 0, this implies that there's
        -:    4:// no clear spec on what that number should be.  As a notable example,
        -:    5:// if all regions incident on a face are deleted, should the face be
        -:    6:// deleted?
        6:    7:static void vTestEntityCounts(const iMesh_Instance instance,
        -:    8:			      const iBase_EntitySetHandle ent_set,
        -:    9:			      const int exp_num_edges, 
        -:   10:			      const int exp_num_tris,
        -:   11:			      const int exp_num_quads, 
        -:   12:			      const int exp_num_tets,
        -:   13:			      const int exp_num_pyrs, 
        -:   14:			      const int exp_num_prisms,
        -:   15:			      const int exp_num_hexes)
        -:   16:{
        -:   17:  int err;
        6:   18:  if (a2iAdjTable[1][1] != iBase_UNAVAILABLE && exp_num_edges >= 0) {
        -:   19:    int num_edges;
        -:   20:    iMesh_getNumOfTopo(instance, ent_set, iMesh_LINE_SEGMENT,
    #####:   21:		       &num_edges, &err);
    #####:   22:    TESTEQ(num_edges, exp_num_edges);
        -:   23:  }
        -:   24:  
        6:   25:  if (a2iAdjTable[2][2] != iBase_UNAVAILABLE && 
        -:   26:      (exp_num_tris >= 0 || exp_num_quads >= 0)) {
        -:   27:    int num_quads, num_tris;
        -:   28:    iMesh_getNumOfTopo(instance, ent_set, iMesh_TRIANGLE,
        5:   29:		       &num_tris, &err);
        5:   30:    TESTEQ(num_tris, exp_num_tris);
        -:   31:    
        -:   32:    iMesh_getNumOfTopo(instance, ent_set, iMesh_QUADRILATERAL,
        5:   33:		       &num_quads, &err);
        5:   34:    TESTEQ(num_quads, exp_num_quads);
        -:   35:  }
        -:   36:  
        -:   37:  // a2iAdjTable[3][3] == iBase_AVAILABLE; that's already been
        -:   38:  // tested elsewhere.
        -:   39:  int num_tets, num_prisms, num_pyramids, num_hexes;
        -:   40:  iMesh_getNumOfTopo(instance, ent_set, iMesh_TETRAHEDRON,
        6:   41:		     &num_tets, &err);
        6:   42:  TESTEQ(num_tets, exp_num_tets);
        -:   43:  iMesh_getNumOfTopo(instance, ent_set, iMesh_PRISM,
        6:   44:		     &num_prisms, &err);
        6:   45:  TESTEQ(num_prisms, exp_num_prisms);
        -:   46:  iMesh_getNumOfTopo(instance, ent_set, iMesh_PYRAMID,
        6:   47:		     &num_pyramids, &err);
        6:   48:  TESTEQ(num_pyramids, exp_num_pyrs);
        -:   49:  iMesh_getNumOfTopo(instance, ent_set, iMesh_HEXAHEDRON,
        6:   50:		     &num_hexes, &err);
        6:   51:  TESTEQ(num_hexes, exp_num_hexes);
        6:   52:}      
        -:   53:
        -:   54:// Test stuff specific to interface Modify.  Those functions are:
        -:   55://     setVtxCoords, createVtx, createEnt, deleteEnt
        1:   56:void vTestModifyInterface(iMesh_Instance& instance)
        -:   57:{
        -:   58:  int err;
        1:   59:  cout << "Modify interface is currently only tested thoroughly in 2D" << endl;
        -:   60:  int iGeomDim;
        1:   61:  iMesh_getGeometricDimension(instance, &iGeomDim, &err);
        1:   62:  CHECK_ERR(err);
        -:   63:  bool qOK;
        -:   64:  int iCoords1Size, iNVerts;
        1:   65:  int SO = iBase_INTERLEAVED;
        -:   66:
        -:   67:  {
        -:   68:    // setVtxCoords is trivial to test:  get a vertex, change its coords,
        -:   69:    // and verify that the change worked.
        1:   70:    iBase_EntityHandle *aVerts = NULL;
        1:   71:    int iVertsAlloc = 0;
        -:   72:    iMesh_getEntities(instance, pvRootSet, iBase_VERTEX, iMesh_POINT,
        1:   73:		      &aVerts, &iVertsAlloc, &iNVerts, &err);
        1:   74:    CHECK_ERR(err);
        -:   75:
        1:   76:    double *adCoords1 = NULL;
        1:   77:    int iCoords1Alloc = 0;
        -:   78:    iMesh_getVtxArrCoords(instance, aVerts, iNVerts,
        -:   79:			  SO, &adCoords1, &iCoords1Alloc, &iCoords1Size,
        1:   80:			  &err);
        1:   81:    CHECK_ERR(err);
        1:   82:    iBase_EntityHandle vertex = aVerts[(0)];
        -:   83:
        1:   84:    int iVert = 0;
        -:   85:    {
        1:   86:      cout << " Setting vertex coordinates..." << endl;
        1:   87:      double adCoords[iGeomDim];
        4:   88:      for (int i = 0; i < iGeomDim; i++) {
        3:   89:	adCoords[i] = i + adCoords1[(i)];
        -:   90:      }
        -:   91:
        1:   92:      if (iGeomDim == 2) {
        -:   93:	// In 2D, should throw an error here.
    #####:   94:	iMesh_setVtxCoord(instance, vertex, adCoords[0], adCoords[1], 0, &err);
    #####:   95:	CHECK_ERR(err);
        -:   96:      }
        1:   97:      else if (iGeomDim == 3) {
        -:   98:	iMesh_setVtxCoord(instance, vertex,
        1:   99:			  adCoords[0], adCoords[1], adCoords[2], &err);
        1:  100:	CHECK_ERR(err);
        -:  101:      }
        -:  102:
        1:  103:      double * adCoords2 = NULL;
        -:  104:      int iCoords2Size;
        1:  105:      int iCoords2Alloc = 0;
        -:  106:      iMesh_getVtxArrCoords(instance, aVerts, iNVerts, SO,
        1:  107:			    &adCoords2, &iCoords2Alloc, &iCoords2Size, &err);
        1:  108:      CHECK_ERR(err);
        -:  109:
        1:  110:      qOK = (iCoords2Size == iCoords1Size);
        4:  111:      for (int i = 0; i < iGeomDim; i++) {
        9:  112:	qOK = qOK && (APPROX_EQUAL(adCoords1[(i)],
       12:  113:				   adCoords2[(i)] - i));
        -:  114:      }
        1:  115:      TEST(qOK);
        1:  116:      UT_FREE(adCoords2);
        1:  117:      UT_FREE(aVerts);
        -:  118:      
        -:  119:      // Now set them back.
        1:  120:      if (iGeomDim == 3)
        -:  121:	iMesh_setVtxCoord(instance, vertex, adCoords1[0], adCoords1[1],
        1:  122:			  adCoords1[2], &err);
        -:  123:      else 
        -:  124:	iMesh_setVtxCoord(instance, vertex, adCoords1[0], adCoords1[1],
    #####:  125:			  0, &err);
        1:  126:      CHECK_ERR(err);
        1:  127:      UT_FREE(adCoords1);
        -:  128:    }
        -:  129:  }
        1:  130:  vDoSaveLoad(&instance, &pvRootSet);
        -:  131:
        -:  132:
        -:  133:  // Now create a new vertex.  Then verify that its handle and
        -:  134:  // coordinates are returned properly.
        -:  135:  {
        1:  136:    cout << " Creating a new vertex..." << endl;
        1:  137:    double adCoords[] = {0,0,0};
        -:  138:
        1:  139:    switch (iGeomDim) {
        -:  140:    case 3:
        1:  141:      adCoords[2] = 1.414; // approx sqrt(2)
        -:  142:    case 2:
        1:  143:      adCoords[1] = 2.8128; // approx e
        -:  144:    case 1:
        1:  145:      adCoords[0] = 3.14159; // approx pi
        -:  146:      break;
        -:  147:    default:
    #####:  148:      assert(0);
        -:  149:    }
        -:  150:
        -:  151:    iBase_EntityHandle new_vert;
        1:  152:    if (iGeomDim == 2) {
    #####:  153:      iMesh_createVtx(instance, adCoords[0], adCoords[1], 0, &new_vert, &err);
    #####:  154:      CHECK_ERR(err);
        -:  155:    }
        1:  156:    else if (iGeomDim == 3) {
        -:  157:      iMesh_createVtx(instance, adCoords[0], adCoords[1], adCoords[2],
        1:  158:		      &new_vert, &err);
        1:  159:      CHECK_ERR(err);
        -:  160:    }
        -:  161:
        1:  162:    double adCoords2[] = {0,0,0};
        -:  163:    iMesh_getVtxCoord(instance, new_vert,
        1:  164:		      &adCoords2[0], &adCoords2[1], &adCoords2[2], &err);
        1:  165:    CHECK_ERR(err);
        -:  166:
        4:  167:    for (int i = 0; i < iGeomDim; i++) {
        3:  168:      qOK = qOK && (APPROX_EQUAL(adCoords2[i], adCoords[i]));
        -:  169:    }
        1:  170:    TEST(qOK);
        1:  171:    iMesh_deleteEnt(instance, new_vert, &err);
        1:  172:    CHECK_ERR(err);
        -:  173:    // Make sure it actually got deleted.
        -:  174:    {
        -:  175:      int iNTopo;
        1:  176:      iMesh_getNumOfTopo(instance, pvRootSet, iMesh_POINT, &iNTopo, &err);
        1:  177:      CHECK_ERR(err);
        1:  178:      TEST(iNTopo * iGeomDim == iCoords1Size);
        -:  179:    }
        -:  180:  }
        -:  181:
        -:  182:  // Test entity creation.  All created entities go into the following
        -:  183:  // containers for orderly deletion later.   Note that
        -:  184:  // iMesh must support Modify, or we wouldn't even be in
        -:  185:  // this subroutine.
        1:  186:  if (iGeomDim == 2) {
        -:  187:    iMesh_Instance new_instance;
    #####:  188:    iMesh_newMesh("", &new_instance, &err, 0);
        -:  189:
    #####:  190:    iMesh_setGeometricDimension(new_instance, 2, &err);
    #####:  191:    qOK = true;
    #####:  192:    cout << " Creating mini 2D mesh..." << endl;
        -:  193:    // First, create some verts.  The first six can be used to create
        -:  194:    // two quads; verts 1, 2, 6, 7 to create two independent triangles.
        -:  195:    // Sketch:
        -:  196:    //
        -:  197:    //
        -:  198:    //
        -:  199:    //
        -:  200:    //       5 --5-- 4
        -:  201:    //       |       |
        -:  202:    //       6       4
        -:  203:    //       |       |
        -:  204:    //       3 --2-- 2 --9-- 7
        -:  205:    //       |       |     / |
        -:  206:    //       3       1   10  8
        -:  207:    //       |       | /     |
        -:  208:    //       0 --0-- 1 --7-- 6
        -:  209:    //
        -:  210:    double adAllCoords[] = {0, 0,
        -:  211:			    1, 0,
        -:  212:			    1, 1,
        -:  213:			    0, 1,
        -:  214:			    1, 2,
        -:  215:			    0, 2,
        -:  216:			    2, 0,
    #####:  217:			    2, 1};
    #####:  218:    cout << "   Creating eight vertices..." << endl;
        -:  219:
        -:  220:    iBase_EntityHandle aNewVerts[8];
    #####:  221:    for (int iV = 0; iV < 8; iV++) {
        -:  222:      iMesh_createVtx(new_instance, adAllCoords[2*iV], adAllCoords[2*iV+1], 0,
    #####:  223:		      &aNewVerts[iV], &err);
    #####:  224:      CHECK_ERR(err);
        -:  225:    }
        -:  226:    iBase_EntitySetHandle localRootSet;
    #####:  227:    iMesh_getRootSet(new_instance, &localRootSet, &err);
    #####:  228:    CHECK_ERR(err);
        -:  229:
    #####:  230:    cout << "   Attempting to create eleven edges...";
    #####:  231:    iBase_EntityHandle aEdgeVerts[] = {aNewVerts[0], aNewVerts[1],
    #####:  232:			  aNewVerts[1], aNewVerts[2],
    #####:  233:			  aNewVerts[2], aNewVerts[3],
    #####:  234:			  aNewVerts[3], aNewVerts[0],
    #####:  235:			  aNewVerts[2], aNewVerts[4],
    #####:  236:			  aNewVerts[4], aNewVerts[5],
    #####:  237:			  aNewVerts[3], aNewVerts[5],
    #####:  238:			  aNewVerts[1], aNewVerts[6],
    #####:  239:			  aNewVerts[6], aNewVerts[7],
    #####:  240:			  aNewVerts[7], aNewVerts[2],
    #####:  241:			  aNewVerts[1], aNewVerts[7]};
        -:  242:
        -:  243:    iBase_EntityHandle aNewEdges[11], aNewTris[2], aNewQuads[2];
    #####:  244:    bool qEdgesOK = false, qTriOK = false, qQuadOK = false;
        -:  245:
        -:  246:    int CStat;
        -:  247:
    #####:  248:    for (int iE = 0; iE < 11; iE++) {
        -:  249:      // This will throw an error if the implementation can't build
        -:  250:      // edges from verts.
        -:  251:      iMesh_createEnt(new_instance, iMesh_LINE_SEGMENT,
    #####:  252:		      aEdgeVerts + 2*iE, 2, &aNewEdges[iE], &CStat, &err);
    #####:  253:      CHECK_ERR(err);
    #####:  254:      qOK = (err == iBase_SUCCESS && CStat == iBase_NEW);
        -:  255:      // Check that the edge has the right verts
        -:  256:      {
    #####:  257:	iBase_EntityHandle *aVertsCheck = NULL;
        -:  258:	int iNV;
    #####:  259:	int iaVertsCheckAlloc = 0;
        -:  260:	iMesh_getEntAdj(new_instance, aNewEdges[iE], iBase_VERTEX,
    #####:  261:			&aVertsCheck, &iaVertsCheckAlloc, &iNV, &err);
    #####:  262:	CHECK_ERR(err);
        -:  263:	qOK = qOK && ((iNV == 2) &&
    #####:  264:		      ((aVertsCheck[0] == aEdgeVerts[2*iE] &&
    #####:  265:			aVertsCheck[1] == aEdgeVerts[2*iE+1]) ||
    #####:  266:		       (aVertsCheck[1] == aEdgeVerts[2*iE] &&
    #####:  267:			aVertsCheck[0] == aEdgeVerts[2*iE+1])));
    #####:  268:	UT_FREE(aVertsCheck);
        -:  269:      }
        -:  270:    }
    #####:  271:    qEdgesOK = qOK;
        -:  272:
        -:  273://     if (qEdgesOK) {
        -:  274://       // Now make sure that trying this again doesn't cause problems.
        -:  275://       for (int iE = 0; iE < 11; iE++) {
        -:  276:// 	iMesh_createEnt(new_instance, iMesh_LINE_SEGMENT,
        -:  277:// 			aEdgeVerts + 2*iE, 2, &aNewEdges[iE], &CStat, &err);
        -:  278:// 	qOK = qOK && ((CStat == iBase_ALREADY_EXISTED) ||
        -:  279:// 		      (CStat == iBase_CREATED_DUPLICATE));
        -:  280:// 	CHECK_ERR(err);
        -:  281://       }
        -:  282://       cout << endl;
        -:  283://       TEST(qOK);
        -:  284:
        -:  285://       qOK = true;
        -:  286://     }
        -:  287:
    #####:  288:    if (qEdgesOK) {
        -:  289:      // Now try to create two triangles from edges.
    #####:  290:      cout << "   Attempting to create two triangles from edges..." << endl;
        -:  291:      // These triangles are built from edges (1, 10, 9) and (7, 8, 10).
    #####:  292:      iBase_EntityHandle aTriEdges[] = {aNewEdges[1], aNewEdges[10], aNewEdges[9],
    #####:  293:			   aNewEdges[7], aNewEdges[8], aNewEdges[10]};
        -:  294:      
        -:  295:      int CStat;
        -:  296:
    #####:  297:      for (int iTri = 0; iTri < 2; iTri++) {
        -:  298:	iMesh_createEnt(new_instance, iMesh_TRIANGLE, aTriEdges + 3*iTri, 3,
    #####:  299:			&aNewTris[iTri], &CStat, &err);
    #####:  300:	CHECK_ERR(err);
    #####:  301:	qOK = qOK && (CStat == iBase_NEW);
        -:  302:
        -:  303:	// Check that the tri has the right edges
        -:  304:	{
    #####:  305:	  iBase_EntityHandle *aEdgesCheck = NULL;
        -:  306:	  int iNE;
    #####:  307:	  int iEdgesCheckAlloc = 0;
        -:  308:	  iMesh_getEntAdj(new_instance, aNewTris[iTri], iBase_EDGE,
    #####:  309:			  &aEdgesCheck, &iEdgesCheckAlloc, &iNE, &err);
    #####:  310:	  CHECK_ERR(err);
        -:  311:	  // Must be in cyclic order, so only three possibilities exist.
        -:  312:	  qOK = qOK && ((iNE == 3) &&
    #####:  313:			((aEdgesCheck[0] == aTriEdges[3*iTri] &&
    #####:  314:			  aEdgesCheck[1] == aTriEdges[3*iTri+1] &&
    #####:  315:			  aEdgesCheck[2] == aTriEdges[3*iTri+2]) ||
    #####:  316:			 (aEdgesCheck[1] == aTriEdges[3*iTri] &&
    #####:  317:			  aEdgesCheck[2] == aTriEdges[3*iTri+1] &&
    #####:  318:			  aEdgesCheck[0] == aTriEdges[3*iTri+2]) ||
    #####:  319:			 (aEdgesCheck[2] == aTriEdges[3*iTri] &&
    #####:  320:			  aEdgesCheck[0] == aTriEdges[3*iTri+1] &&
    #####:  321:			  aEdgesCheck[1] == aTriEdges[3*iTri+2])));
    #####:  322:	  UT_FREE(aEdgesCheck);
        -:  323:	}
        -:  324:      }
        -:  325:
        -:  326:      // Verify edge-to-tri connectivity.
        -:  327:      {
        -:  328:	// There's only one edge that has two adjacent triangles; the
        -:  329:	// others have a triangle and something undefined adjacent to
        -:  330:	// them.  So check just that one edge, which is edge 10.
    #####:  331:	iBase_EntityHandle *aTri = NULL;
        -:  332:	int iNumTri;
    #####:  333:	int iTriAlloc = 0;
        -:  334:	iMesh_getEntAdj(new_instance, aNewEdges[10], iBase_FACE,
    #####:  335:			&aTri, &iTriAlloc, &iNumTri, &err);
    #####:  336:	CHECK_ERR(err);
        -:  337:	qOK = qOK && (iNumTri == 2)
    #####:  338:	  && ((aTri[0] == aNewTris[0] && aTri[1] == aNewTris[1]) ||
    #####:  339:	      (aTri[0] == aNewTris[1] && aTri[1] == aNewTris[0]));
    #####:  340:	UT_FREE(aTri);
        -:  341:      }
    #####:  342:      qTriOK = qOK;
        -:  343:
        -:  344://       if (qTriOK) {
        -:  345:// 	// Now make sure that trying this again doesn't cause problems.
        -:  346:// 	for (int iTri = 0; iTri < 2; iTri++) {
        -:  347:// 	  iBase_EntityHandle new_tri;
        -:  348:// 	  iMesh_createEnt(new_instance, iMesh_TRIANGLE, aTriEdges + 3*iTri, 3,
        -:  349:// 			  &new_tri, &CStat, &err);
        -:  350:// 	  CHECK_ERR(err);
        -:  351:// 	  qOK = qOK && ((CStat == iBase_ALREADY_EXISTED) ||
        -:  352:// 			CStat == iBase_CREATED_DUPLICATE);
        -:  353:// 	}
        -:  354://       }
        -:  355:
    #####:  356:      if (!qTriOK) {
    #####:  357:	cout << "    no support for building triangles from edges" << endl;
        -:  358:      }
        -:  359:
    #####:  360:      TEST(qOK);
    #####:  361:      qOK = true;
        -:  362:
        -:  363:      // Now try to create two quadrilaterals from edges.
        -:  364:      cout << "   Attempting to create two quadrilaterals from edges..."
    #####:  365:	   << endl;
        -:  366:      // These quadrilaterals are built from edges (0, 1, 2, 3) and
        -:  367:      // (2, 4, 5, 6).
        -:  368:      iBase_EntityHandle aQuadEdges[] =
    #####:  369:	{aNewEdges[0], aNewEdges[1], aNewEdges[2], aNewEdges[3],
    #####:  370:	 aNewEdges[2], aNewEdges[4], aNewEdges[5], aNewEdges[6]};
        -:  371:
    #####:  372:      for (int iQuad = 0; iQuad < 2; iQuad++) {
        -:  373:	iMesh_createEnt(new_instance, iMesh_QUADRILATERAL, aQuadEdges + 4*iQuad, 4,
    #####:  374:			&aNewQuads[iQuad], &CStat, &err);
    #####:  375:	CHECK_ERR(err);
    #####:  376:	qOK = qOK && (CStat == iBase_NEW);
        -:  377:
        -:  378:	// Check that the quad has the right edges
        -:  379:	{
    #####:  380:	  iBase_EntityHandle *aEdgesCheck = NULL;
        -:  381:	  int iNE;
    #####:  382:	  int iEdgesCheckAlloc = 0;
        -:  383:	  iMesh_getEntAdj(new_instance, aNewQuads[iQuad], iBase_EDGE,
    #####:  384:			  &aEdgesCheck, &iEdgesCheckAlloc, &iNE, &err);
    #####:  385:	  CHECK_ERR(err);
        -:  386:	  // Must be in cyclic order, so only four possibilities exist.
        -:  387:	  qOK = qOK && ((iNE == 4) &&
    #####:  388:			((aEdgesCheck[0] == aQuadEdges[4*iQuad] &&
    #####:  389:			  aEdgesCheck[1] == aQuadEdges[4*iQuad+1] &&
    #####:  390:			  aEdgesCheck[2] == aQuadEdges[4*iQuad+2] &&
    #####:  391:			  aEdgesCheck[3] == aQuadEdges[4*iQuad+3]) ||
    #####:  392:			 (aEdgesCheck[1] == aQuadEdges[4*iQuad] &&
    #####:  393:			  aEdgesCheck[2] == aQuadEdges[4*iQuad+1] &&
    #####:  394:			  aEdgesCheck[3] == aQuadEdges[4*iQuad+2] &&
    #####:  395:			  aEdgesCheck[0] == aQuadEdges[4*iQuad+3]) ||
    #####:  396:			 (aEdgesCheck[2] == aQuadEdges[4*iQuad] &&
    #####:  397:			  aEdgesCheck[3] == aQuadEdges[4*iQuad+1] &&
    #####:  398:			  aEdgesCheck[0] == aQuadEdges[4*iQuad+2] &&
    #####:  399:			  aEdgesCheck[1] == aQuadEdges[4*iQuad+3]) ||
    #####:  400:			 (aEdgesCheck[3] == aQuadEdges[4*iQuad] &&
    #####:  401:			  aEdgesCheck[0] == aQuadEdges[4*iQuad+1] &&
    #####:  402:			  aEdgesCheck[1] == aQuadEdges[4*iQuad+2] &&
    #####:  403:			  aEdgesCheck[2] == aQuadEdges[4*iQuad+3])));
    #####:  404:	  UT_FREE(aEdgesCheck);
        -:  405:	}
        -:  406:      }
        -:  407:
        -:  408:      // Verify edge-to-quad connectivity.
        -:  409:      {
        -:  410:	// There's only one edge that has two adjacent quadrilaterals; the
        -:  411:	// others have a quad and something undefined adjacent to
        -:  412:	// them.  So check just that one edge, which is edge 2.
    #####:  413:	iBase_EntityHandle *aQuad = NULL;
        -:  414:	int iNumQuad;
    #####:  415:	int iQuadAlloc = 0;
        -:  416:	iMesh_getEntAdj(new_instance, aNewEdges[2], iBase_FACE,
    #####:  417:			&aQuad, &iQuadAlloc, &iNumQuad, &err);
    #####:  418:	CHECK_ERR(err);
        -:  419:	qOK = qOK && (iNumQuad == 2)
    #####:  420:	  && ((aQuad[0] == aNewQuads[0] && aQuad[1] == aNewQuads[1]) ||
    #####:  421:	      (aQuad[0] == aNewQuads[1] && aQuad[1] == aNewQuads[0]));
    #####:  422:	UT_FREE(aQuad);
        -:  423:      }
    #####:  424:      qQuadOK = qOK;
        -:  425:
        -:  426:      // Now make sure that trying this again doesn't cause problems.
    #####:  427:      if (qQuadOK) {
        -:  428:	// If tris were also built successfully, verify edge-tri/quad
        -:  429:	// connectivity.
    #####:  430:	if (qTriOK) {
        -:  431:	  // There's only one edge that is between a tri and a quad:
        -:  432:	  // edge 1.
    #####:  433:	  iBase_EntityHandle *aFace = NULL;
        -:  434:	  int iNumFace;
    #####:  435:	  int iFaceAlloc = 0;
        -:  436:	  iMesh_getEntAdj(new_instance, aNewEdges[1], iBase_FACE,
    #####:  437:			  &aFace, &iFaceAlloc, &iNumFace, &err);
    #####:  438:	  CHECK_ERR(err);
        -:  439:	  qOK = qOK && (iNumFace == 2)
    #####:  440:	    && ((aFace[0] == aNewQuads[0] && aFace[1] == aNewTris[0]) ||
    #####:  441:		(aFace[0] == aNewTris[0] && aFace[1] == aNewQuads[0]));
    #####:  442:	  UT_FREE(aFace);
        -:  443:	}
        -:  444:
        -:  445:// 	for (int iQuad = 0; iQuad < 2; iQuad++) {
        -:  446:// 	  iBase_EntityHandle new_quad;
        -:  447:// 	  iMesh_createEnt(new_instance, iMesh_QUADRILATERAL,
        -:  448:// 			  aQuadEdges + 4*iQuad, 4, &new_quad, &CStat, &err);
        -:  449:// 	  CHECK_ERR(err);
        -:  450:// 	  qOK = qOK && ((CStat == iBase_ALREADY_EXISTED) ||
        -:  451:// 			(CStat == iBase_CREATED_DUPLICATE));
        -:  452:// 	}
        -:  453:      }
    #####:  454:      if (!qQuadOK) {
    #####:  455:	cout << "    no support for building quads from edges" << endl;
        -:  456:      }
        -:  457:
    #####:  458:      TEST(qOK);
    #####:  459:      qOK = true;
        -:  460:    }
        -:  461:
        -:  462:    // Now test entity deletion for all entities recorded.  Along the
        -:  463:    // way, check that entity counts and returned entities are done
        -:  464:    // correctly.
        -:  465:
        -:  466:    // First, verify that low-dimension entities can't be deleted
        -:  467:    // without deleting the entities that depend on them.
        -:  468:    int iNVerts, iNEdges, iNTris, iNQuads;
        -:  469:    iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_POINT,
    #####:  470:		       &iNVerts, &err);
    #####:  471:    CHECK_ERR(err);
        -:  472:    iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_LINE_SEGMENT,
    #####:  473:		       &iNEdges, &err);
    #####:  474:    CHECK_ERR(err);
        -:  475:    iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_TRIANGLE,
    #####:  476:		       &iNTris, &err);
    #####:  477:    CHECK_ERR(err);
        -:  478:    iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_QUADRILATERAL,
    #####:  479:		       &iNQuads, &err);
    #####:  480:    CHECK_ERR(err);
        -:  481:
    #####:  482:    TESTEQ(iNVerts,8);
    #####:  483:    TEST((iNEdges == 0 && !qEdgesOK) || iNEdges == 11);
    #####:  484:    TEST((iNTris == 0 && !qTriOK) || iNTris == 2);
    #####:  485:    TEST((iNQuads == 0 && !qQuadOK) || iNQuads == 2);
        -:  486:
    #####:  487:    iMesh_deleteEnt(new_instance, aNewVerts[0], &err);
    #####:  488:    CHECK_ERR2(err, iBase_INVALID_ENTITY_HANDLE);
        -:  489:    // Should not succeed in deleting.
        -:  490:
        -:  491:    {
        -:  492:      int iNewNVerts;
        -:  493:      iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_POINT,
    #####:  494:			 &iNewNVerts, &err);
    #####:  495:      CHECK_ERR(err);
    #####:  496:      TESTEQ(iNewNVerts,iNVerts);
        -:  497:
    #####:  498:      if (qTriOK || qQuadOK) {
        -:  499:	// Try to remove the edge that is shared between by a tri and a
        -:  500:	// quad.  Can only get here if edges were created in the first
        -:  501:	// place.  This removal attempt should fail.
    #####:  502:	iMesh_deleteEnt(new_instance, aNewEdges[1], &err);
    #####:  503:	CHECK_ERR2(err, iBase_INVALID_ENTITY_HANDLE);
        -:  504:	int iNewNEdges;
        -:  505:	iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_LINE_SEGMENT,
    #####:  506:			   &iNewNEdges, &err);
    #####:  507:	CHECK_ERR(err);
    #####:  508:	TESTEQ(iNewNEdges,iNEdges);
        -:  509:      }
        -:  510:
        -:  511:      // Now delete one quad (if any exist) and verify that you only
        -:  512:      // get one quad for subsequent requests.
    #####:  513:      if (qQuadOK) {
    #####:  514:	iMesh_deleteEnt(new_instance, aNewQuads[1], &err);
    #####:  515:	CHECK_ERR(err);
    #####:  516:	iBase_EntityHandle *aQuads = NULL;
        -:  517:	int iNQuadAfter;
    #####:  518:	int iQuadsAlloc = 0;
        -:  519:	iMesh_getEntities(new_instance, localRootSet, iBase_FACE,
        -:  520:			  iMesh_QUADRILATERAL,
    #####:  521:			  &aQuads, &iQuadsAlloc, &iNQuadAfter, &err);
    #####:  522:	CHECK_ERR(err);
    #####:  523:	TESTEQ(iNQuadAfter,1);
        -:  524:	iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_QUADRILATERAL,
    #####:  525:			   &iNQuadAfter, &err);
    #####:  526:	CHECK_ERR(err);
    #####:  527:	TESTEQ(iNQuadAfter,1);
    #####:  528:	UT_FREE(aQuads);
        -:  529:      }
        -:  530:
        -:  531:      // Repeat the previous test for triangles.
    #####:  532:      if (qTriOK) {
    #####:  533:	iMesh_deleteEnt(new_instance, aNewTris[1], &err);
    #####:  534:	CHECK_ERR(err);
    #####:  535:	iBase_EntityHandle *aTris = NULL;
        -:  536:	int iNTriAfter;
    #####:  537:	int iTrisAlloc = 0;
        -:  538:	iMesh_getEntities(new_instance, localRootSet, iBase_FACE,
        -:  539:			   iMesh_TRIANGLE,
    #####:  540:			  &aTris, &iTrisAlloc, &iNTriAfter, &err);
    #####:  541:	CHECK_ERR(err);
    #####:  542:	TESTEQ(iNTriAfter,1);
        -:  543:	iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_TRIANGLE,
    #####:  544:			   &iNTriAfter, &err);
    #####:  545:	CHECK_ERR(err);
    #####:  546:	TESTEQ(iNTriAfter,1);
    #####:  547:	UT_FREE(aTris);
        -:  548:      }
        -:  549:
        -:  550:      // Now delete the rest of the faces.
    #####:  551:      if (qQuadOK) iMesh_deleteEnt(new_instance, aNewQuads[0], &err);
    #####:  552:      CHECK_ERR(err);
    #####:  553:      if (qTriOK)  iMesh_deleteEnt(new_instance, aNewTris[0], &err);
    #####:  554:      CHECK_ERR(err);
        -:  555:      int iNewNTris, iNewNQuads, iNewNFaces;
        -:  556:      iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_QUADRILATERAL,
    #####:  557:			 &iNewNQuads, &err);
    #####:  558:      CHECK_ERR(err);
        -:  559:      iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_TRIANGLE,
    #####:  560:			 &iNewNTris, &err);
    #####:  561:      CHECK_ERR(err);
        -:  562:      iMesh_getNumOfType(new_instance, localRootSet, iBase_FACE,
    #####:  563:			 &iNewNFaces, &err);
    #####:  564:      CHECK_ERR(err);
    #####:  565:      TEST(iNewNQuads == 0 && iNewNTris == 0 && iNewNFaces == 0);
        -:  566:
        -:  567:      // Repeat the single-deletion test for edges.
        -:  568:      {
    #####:  569:	iMesh_deleteEnt(new_instance, aNewEdges[10], &err);
    #####:  570:	CHECK_ERR(err);
    #####:  571:	iBase_EntityHandle *aEdges = NULL;
        -:  572:	int iNEdgeAfter;
    #####:  573:	int iaEdgesAlloc = 0;
        -:  574:	iMesh_getEntities(new_instance, localRootSet, iBase_EDGE,
        -:  575:			   iMesh_LINE_SEGMENT,
    #####:  576:			  &aEdges, &iaEdgesAlloc, &iNEdgeAfter, &err);
    #####:  577:	CHECK_ERR(err);
    #####:  578:	TESTEQ(iNEdgeAfter,10);
        -:  579:	iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_LINE_SEGMENT,
    #####:  580:			   &iNEdgeAfter, &err);
    #####:  581:	CHECK_ERR(err);
    #####:  582:	TESTEQ(iNEdgeAfter,10);
        -:  583:	iMesh_getNumOfType(new_instance, localRootSet, iBase_EDGE,
    #####:  584:			   &iNEdgeAfter, &err);
    #####:  585:	CHECK_ERR(err);
    #####:  586:	TESTEQ(iNEdgeAfter,10);
    #####:  587:	UT_FREE(aEdges);
        -:  588:      }
        -:  589:
        -:  590:      // Delete the remaining edges.
        -:  591:      int i;
    #####:  592:      for (i = 0; i < 10; i++) {
    #####:  593:	iMesh_deleteEnt(new_instance, aNewEdges[i], &err);
    #####:  594:	CHECK_ERR(err);
        -:  595:      }
        -:  596:      int iNewNSegs, iNewNEdges;
        -:  597:      iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_LINE_SEGMENT,
    #####:  598:			 &iNewNSegs, &err);
    #####:  599:      CHECK_ERR(err);
        -:  600:      iMesh_getNumOfType(new_instance, localRootSet, iBase_EDGE,
    #####:  601:			 &iNewNEdges, &err);
    #####:  602:      CHECK_ERR(err);
    #####:  603:      TEST(iNewNSegs == 0 && iNewNEdges == 0);
        -:  604:
        -:  605:      // Delete all the verts.
    #####:  606:      for (i = 0; i < 8; i++) {
    #####:  607:	iMesh_deleteEnt(new_instance, aNewVerts[i], &err);
    #####:  608:	CHECK_ERR(err);
        -:  609:      }
        -:  610:      int iNewNPts;
        -:  611:      iMesh_getNumOfTopo(new_instance, localRootSet, iMesh_POINT,
    #####:  612:			 &iNewNPts, &err);
    #####:  613:      CHECK_ERR(err);
        -:  614:      iMesh_getNumOfType(new_instance, localRootSet, iBase_VERTEX,
    #####:  615:			 &iNewNVerts, &err);
    #####:  616:      CHECK_ERR(err);
        -:  617:    }
        -:  618:    // Done with creating stuff via edges.
        -:  619:
        -:  620:    // Now test again, creating tris and quads directly from verts.
        -:  621:
        -:  622:    // Create the verts again, because you just deleted them.
    #####:  623:    for (int iV = 0; iV < 8; iV++) {
        -:  624:      iMesh_createVtx(new_instance, adAllCoords[2*iV], adAllCoords[2*iV+1], 0,
    #####:  625:		      &aNewVerts[iV], &err);
    #####:  626:      CHECK_ERR(err);
        -:  627:    }
    #####:  628:    cout << "   Attempting to create two triangles from verts..." << endl;
        -:  629:    // First, try to create two triangles.
    #####:  630:    iBase_EntityHandle aTriVerts[] = {aNewVerts[1], aNewVerts[6], aNewVerts[7],
    #####:  631:			 aNewVerts[7], aNewVerts[2], aNewVerts[1]};
        -:  632:
    #####:  633:    qTriOK = true;
        -:  634:
    #####:  635:    for (int iTri = 0; iTri < 2; iTri++) {
        -:  636:      iMesh_createEnt(new_instance, iMesh_TRIANGLE, aTriVerts + 3*iTri, 3,
    #####:  637:		      &aNewTris[iTri], &CStat, &err);
    #####:  638:      CHECK_ERR(err);
    #####:  639:      qOK = qOK && (CStat == iBase_NEW);
        -:  640:
        -:  641:      // Check that the tri has the right verts
        -:  642:      {
    #####:  643:	iBase_EntityHandle *aVertsCheck = NULL;
        -:  644:	int iNE;
    #####:  645:	int iVertsCheckAlloc = 0;
        -:  646:	iMesh_getEntAdj(new_instance, aNewTris[iTri], iBase_VERTEX,
    #####:  647:			&aVertsCheck, &iVertsCheckAlloc, &iNE, &err);
    #####:  648:	CHECK_ERR(err);
        -:  649:	// Must be in cyclic order, so only three possibilities exist.
        -:  650:	qOK = qOK && ((iNE == 3) &&
    #####:  651:		      ((aVertsCheck[0] == aTriVerts[3*iTri] &&
    #####:  652:			aVertsCheck[1] == aTriVerts[3*iTri+1] &&
    #####:  653:			aVertsCheck[2] == aTriVerts[3*iTri+2]) ||
    #####:  654:		       (aVertsCheck[1] == aTriVerts[3*iTri] &&
    #####:  655:			aVertsCheck[2] == aTriVerts[3*iTri+1] &&
    #####:  656:			aVertsCheck[0] == aTriVerts[3*iTri+2]) ||
    #####:  657:		       (aVertsCheck[2] == aTriVerts[3*iTri] &&
    #####:  658:			aVertsCheck[0] == aTriVerts[3*iTri+1] &&
    #####:  659:			aVertsCheck[1] == aTriVerts[3*iTri+2])));
    #####:  660:	UT_FREE(aVertsCheck);
        -:  661:      }
        -:  662:    } // Done making and checking all tris.
    #####:  663:    qTriOK = qOK;
        -:  664:
        -:  665://     if (qTriOK) {
        -:  666://       // Now make sure that trying this again doesn't cause problems.
        -:  667://       for (int iTri = 0; iTri < 2; iTri++) {
        -:  668:// 	iBase_EntityHandle new_tri;
        -:  669:// 	iMesh_createEnt(new_instance, iMesh_TRIANGLE,
        -:  670:// 			aTriVerts + 3*iTri, 3, &new_tri, &CStat, &err);
        -:  671:// 	CHECK_ERR(err);
        -:  672:// 	qOK = qOK && ((CStat == iBase_ALREADY_EXISTED) ||
        -:  673:// 		      (CStat == iBase_CREATED_DUPLICATE));
        -:  674://       }
        -:  675://     }
    #####:  676:    TEST(qOK);
    #####:  677:    qOK = true;
        -:  678:
        -:  679:    // Should have five edges.
        -:  680:    iMesh_getNumOfType(new_instance, localRootSet, iBase_EDGE,
    #####:  681:		       &iNEdges, &err);
    #####:  682:    CHECK_ERR(err);
    #####:  683:    TESTEQ(5,iNEdges);
        -:  684:
    #####:  685:    if (!qTriOK) {
    #####:  686:      cout << "    no support for building triangles from vertices" << endl;
        -:  687:    }
        -:  688:
        -:  689:    // Done trying to create triangles from vertices.
        -:  690:
    #####:  691:    cout << "   Attempting to create two quadrilaterals from verts..." << endl;
        -:  692:    // First, try to create two quads.
        -:  693:    iBase_EntityHandle aQuadVerts[] =
    #####:  694:      {aNewVerts[0], aNewVerts[1], aNewVerts[2], aNewVerts[3],
    #####:  695:       aNewVerts[3], aNewVerts[2], aNewVerts[4], aNewVerts[5]};
        -:  696:
    #####:  697:    qQuadOK = true;
        -:  698:
    #####:  699:    for (int iQuad = 0; iQuad < 2; iQuad++) {
        -:  700:      iMesh_createEnt(new_instance, iMesh_QUADRILATERAL, aQuadVerts + 4*iQuad,
    #####:  701:		      4, &aNewQuads[iQuad], &CStat, &err);
    #####:  702:      CHECK_ERR(err);
    #####:  703:      qOK = qOK && (CStat == iBase_NEW);
        -:  704:
        -:  705:      // Check that the quad has the right verts
        -:  706:      {
    #####:  707:	iBase_EntityHandle *aVertsCheck = NULL;
        -:  708:	int iNE;
    #####:  709:	int iVertsCheckAlloc = 0;
        -:  710:	iMesh_getEntAdj(new_instance, aNewQuads[iQuad], iBase_VERTEX,
    #####:  711:			&aVertsCheck, &iVertsCheckAlloc, &iNE, &err);
    #####:  712:	CHECK_ERR(err);
        -:  713:	// Must be in cyclic order, so only three possibilities exist.
        -:  714:	qOK = qOK && ((iNE == 4) &&
    #####:  715:		      ((aVertsCheck[0] == aQuadVerts[4*iQuad] &&
    #####:  716:			aVertsCheck[1] == aQuadVerts[4*iQuad+1] &&
    #####:  717:			aVertsCheck[2] == aQuadVerts[4*iQuad+2] &&
    #####:  718:			aVertsCheck[3] == aQuadVerts[4*iQuad+3]) ||
    #####:  719:		       (aVertsCheck[1] == aQuadVerts[4*iQuad] &&
    #####:  720:			aVertsCheck[2] == aQuadVerts[4*iQuad+1] &&
    #####:  721:			aVertsCheck[3] == aQuadVerts[4*iQuad+2] &&
    #####:  722:			aVertsCheck[0] == aQuadVerts[4*iQuad+3]) ||
    #####:  723:		       (aVertsCheck[2] == aQuadVerts[4*iQuad] &&
    #####:  724:			aVertsCheck[3] == aQuadVerts[4*iQuad+1] &&
    #####:  725:			aVertsCheck[0] == aQuadVerts[4*iQuad+2] &&
    #####:  726:			aVertsCheck[1] == aQuadVerts[4*iQuad+3]) ||
    #####:  727:		       (aVertsCheck[3] == aQuadVerts[4*iQuad] &&
    #####:  728:			aVertsCheck[0] == aQuadVerts[4*iQuad+1] &&
    #####:  729:			aVertsCheck[1] == aQuadVerts[4*iQuad+2] &&
    #####:  730:			aVertsCheck[2] == aQuadVerts[4*iQuad+3])));
    #####:  731:	UT_FREE(aVertsCheck);
        -:  732:      }
        -:  733:    } // Done making and checking all quads.
    #####:  734:    qQuadOK = qOK;
        -:  735:
        -:  736://     if (qQuadOK) {
        -:  737:// 	// Now make sure that trying this again doesn't cause problems.
        -:  738://       for (int iQuad = 0; iQuad < 2; iQuad++) {
        -:  739:// 	iBase_EntityHandle new_quad;
        -:  740:// 	iMesh_createEnt(new_instance, iMesh_QUADRILATERAL,
        -:  741:// 			aQuadVerts + 4*iQuad, 4, &new_quad, &CStat, &err);
        -:  742:// 	CHECK_ERR(err);
        -:  743:// 	qOK = qOK && ((CStat == iBase_ALREADY_EXISTED) ||
        -:  744:// 		      (CStat == iBase_CREATED_DUPLICATE));
        -:  745://       }
        -:  746://     }
    #####:  747:    TEST(qOK);
    #####:  748:    qOK = true;
        -:  749:
    #####:  750:    if (qQuadOK) {
        -:  751:      // Should have seven edges, or 11 if the triangles also built okay.
        -:  752:      iMesh_getNumOfType(new_instance, localRootSet, iBase_EDGE,
    #####:  753:			 &iNEdges, &err);
    #####:  754:      CHECK_ERR(err);
    #####:  755:      TEST( (qTriOK && 11 == iNEdges) || (!qTriOK && 7 == iNEdges) );
        -:  756:    }
        -:  757:    else {
        -:  758:      cout << "    no support for building quadrilaterals from vertices"
    #####:  759:	   << endl;
        -:  760:    }
        -:  761:    // Done trying to create quadrilaterals from vertices.
    #####:  762:    vDoSaveLoad(&new_instance, &localRootSet);
        -:  763:
        -:  764:    // No need to re-test delete.
    #####:  765:    iMesh_dtor(new_instance, &err);
        -:  766:  } // Done with testing create/deleteEnt for 2D.
        1:  767:  else if (iGeomDim == 3) {
        -:  768:    // Now repeat all of the above for the more complex case of testing
        -:  769:    // 3D mesh creation, in (at least some of) the permutations.
        1:  770:    qOK = true;
        -:  771:    // First, create some verts (15, actually).  
        -:  772:    //
        -:  773:    double adAllCoords[] = {-1, 0, 0,
        -:  774:			    0, 0, 0,
        -:  775:			    0, 1, 0,
        -:  776:			    -1, 1, 0,
        -:  777:			    -1, 0, 1,
        -:  778:			    0, 0, 1,
        -:  779:			    0, 1, 1,
        -:  780:			    -1, 1, 1,
        -:  781:			    1, 1, 1,
        -:  782:			    0, 0, -1,
        -:  783:			    1, 0, -1,
        -:  784:			    1, 1, -1,
        -:  785:			    0, 1, -1,
        -:  786:			    1, 0, 0,
        1:  787:			    1, 1, 0};
        -:  788:
        -:  789:    int CStat;
        -:  790:    iBase_EntityHandle aNewRegions[8];
        1:  791:    bool qBuiltRegions = false;
        -:  792:    do {
        -:  793:      iMesh_Instance new_instance;
        1:  794:      iMesh_newMesh("", &new_instance, &err, 0);
        1:  795:      cout << " Creating mini 3D mesh, building regions from verts..." << endl;
        1:  796:      iMesh_setGeometricDimension(new_instance, 3, &err);
        -:  797:      iBase_EntitySetHandle localRootSet;
        1:  798:      iMesh_getRootSet(new_instance, &localRootSet, &err);
        -:  799:      
        1:  800:      cout << "   Creating fifteen vertices..." << endl;
        -:  801:      
        -:  802:      // This had better succeed for any implementation
        -:  803:      iBase_EntityHandle aNewVerts[15];
       16:  804:      for (int iV = 0; iV < 15; iV++) {
        -:  805:	iMesh_createVtx(new_instance, adAllCoords[iGeomDim*iV],
        -:  806:			adAllCoords[iGeomDim*iV+1], adAllCoords[iGeomDim*iV+2], 
       15:  807:			&aNewVerts[iV], &err);
       15:  808:	CHECK_ERR(err);
        -:  809:      }
        -:  810:      
        1:  811:      cout << "   Testing region creation from vertices... " << endl;
        -:  812:      iBase_EntityHandle aTetVerts[] = 
        4:  813:	{aNewVerts[ 9], aNewVerts[10], aNewVerts[12], aNewVerts[ 1],
        4:  814:	 aNewVerts[10], aNewVerts[11], aNewVerts[12], aNewVerts[14],
        4:  815:	 aNewVerts[ 1], aNewVerts[14], aNewVerts[13], aNewVerts[10],
        4:  816:	 aNewVerts[ 1], aNewVerts[ 2], aNewVerts[14], aNewVerts[12],
       17:  817:	 aNewVerts[ 1], aNewVerts[10], aNewVerts[12], aNewVerts[14]};
        1:  818:      bool qTetFromVerts = true;
        -:  819:      iMesh_createEnt(new_instance, iMesh_TETRAHEDRON, aTetVerts,
        1:  820:		      4, &aNewRegions[0], &CStat, &err);
        1:  821:      if (err != iBase_SUCCESS) {
    #####:  822:	cout << "     Can't seem to create regions from verts." << endl;
        -:  823:	break;
        -:  824:      }
        1:  825:      qBuiltRegions = true;
        -:  826:      
        -:  827:      // If you successfully created a single tet from verts, then it's
        -:  828:      // expected that the rest of these will pass, too.
        -:  829:
        5:  830:      for (int iTet = 1; iTet < 5 && qTetFromVerts; iTet++) {
        -:  831:	iMesh_createEnt(new_instance, iMesh_TETRAHEDRON, aTetVerts + 4*iTet,
        4:  832:			4, &aNewRegions[iTet], &CStat, &err);
        -:  833:	qTetFromVerts = qTetFromVerts &&
        4:  834:	  (err == iBase_SUCCESS && CStat == iBase_NEW);
        -:  835:      }
        1:  836:      TEST2(qTetFromVerts, "creating tets from verts");
        1:  837:      if (qTetFromVerts) 
        1:  838:	cout << "     Passed for tets" << endl;
        -:  839:      
        -:  840:      iBase_EntityHandle aPyrVerts[] = 
        4:  841:	{aNewVerts[ 1], aNewVerts[14], aNewVerts[ 8], aNewVerts[ 5],
        5:  842:	 aNewVerts[13]};
        -:  843:      iMesh_createEnt(new_instance, iMesh_PYRAMID, aPyrVerts,
        1:  844:		      5, &aNewRegions[5], &CStat, &err);
        -:  845:      bool qPyramidFromVerts = (err == iBase_SUCCESS &&
        1:  846:				CStat == iBase_NEW);
        1:  847:      TEST2(qPyramidFromVerts, "creating pyramid from verts");
        1:  848:      if (qPyramidFromVerts)
        1:  849:	cout << "     Passed for pyramid" << endl;
        -:  850:      
        -:  851:      iBase_EntityHandle aPrismVerts[] =
        4:  852:	{aNewVerts[ 1], aNewVerts[14], aNewVerts[ 2], aNewVerts[ 5],
        5:  853:	 aNewVerts[ 8], aNewVerts[ 6]};
        -:  854:      iMesh_createEnt(new_instance, iMesh_PRISM, aPrismVerts,
        1:  855:		      6, &aNewRegions[6], &CStat, &err);
        -:  856:      bool qPrismFromVerts = (err == iBase_SUCCESS &&
        1:  857:			      CStat == iBase_NEW);
        1:  858:      TEST2(qPrismFromVerts, "creating prism from verts");
        1:  859:      if (qPrismFromVerts)
        1:  860:	cout << "     Passed for prism" << endl;
        -:  861:      
        -:  862:      iBase_EntityHandle aHexVerts[] = 
        4:  863:	{aNewVerts[ 0], aNewVerts[ 1], aNewVerts[ 2], aNewVerts[ 3],
        5:  864:	 aNewVerts[ 4], aNewVerts[ 5], aNewVerts[ 6], aNewVerts[ 7]};
        -:  865:      iMesh_createEnt(new_instance, iMesh_HEXAHEDRON, aHexVerts,
        1:  866:		      8, &aNewRegions[7], &CStat, &err);
        -:  867:      bool qHexahedronFromVerts = (err == iBase_SUCCESS &&
        1:  868:				   CStat == iBase_NEW);
        1:  869:      TEST2(qHexahedronFromVerts, "creating hex from verts");
        1:  870:      if (qHexahedronFromVerts)
        1:  871:	cout << "     Passed for hexahedron" << endl;
        -:  872:      
        -:  873:      // Check that the number of total entities is correct.
        1:  874:      vTestEntityCounts(new_instance, localRootSet, 34, 20, 8, 5, 1, 1, 1);
        -:  875:      
        1:  876:      cout << "   Deleting a cell in the interior of the mesh and recreating it..." << endl;
        -:  877:      // Get rid of the inner tet and then re-create it.
        1:  878:      iMesh_deleteEnt(new_instance, aNewRegions[4], &err);
        1:  879:      TEST2(err == iBase_SUCCESS, "deleting a tet");
        -:  880:      
        1:  881:      vTestEntityCounts(new_instance, localRootSet, 34, 20, 8, 4, 1, 1, 1);
        -:  882:      iMesh_createEnt(new_instance, iMesh_TETRAHEDRON, aTetVerts + 16,
        1:  883:		      4, &aNewRegions[4], &CStat, &err);
        1:  884:      TEST2(err == iBase_SUCCESS && CStat == iBase_NEW, "recreating a tet");
        1:  885:      vTestEntityCounts(new_instance, localRootSet, 34, 20, 8, 5, 1, 1, 1);
        -:  886:      
        1:  887:      cout << "   Deleting all cells at one go..." << endl;
        1:  888:      iMesh_deleteEntArr(new_instance, aNewRegions, 8, &err);
        1:  889:      TEST2(err == iBase_SUCCESS, "deleting all cells using deleteEntArr");
        1:  890:      vTestEntityCounts(new_instance, localRootSet, -1, -1, -1, 0, 0, 0, 0);
        1:  891:      iMesh_dtor(new_instance, &err);
        -:  892:    } while(0); // Provide a target for a break if creation from verts fails.
        -:  893:
        -:  894:    do {
        -:  895:      iMesh_Instance new_instance;
        1:  896:      iMesh_newMesh("", &new_instance, &err, 0);
        1:  897:      iMesh_setGeometricDimension(new_instance, 3, &err);
        -:  898:      iBase_EntitySetHandle localRootSet;
        1:  899:      iMesh_getRootSet(new_instance, &localRootSet, &err);
        -:  900:      
        1:  901:      cout << "   Creating eight vertices..." << endl;
        -:  902:      
        -:  903:      iBase_EntityHandle aNewVerts[15];
       16:  904:      for (int iV = 0; iV < 15; iV++) {
        -:  905:	iMesh_createVtx(new_instance, adAllCoords[iGeomDim*iV],
        -:  906:			adAllCoords[iGeomDim*iV+1], adAllCoords[iGeomDim*iV+2], 
       15:  907:			&aNewVerts[iV], &err);
       15:  908:	CHECK_ERR(err);
        -:  909:      }
        -:  910:
        1:  911:      cout << "   Testing face creation from vertices..." << endl;
        -:  912:      iBase_EntityHandle aTriVerts[] = 
        3:  913:	{aNewVerts[ 0], aNewVerts[ 1], aNewVerts[ 9], // T0 ; non-manifold
        3:  914:	 aNewVerts[ 9], aNewVerts[10], aNewVerts[ 1], // T1
        3:  915:	 aNewVerts[10], aNewVerts[13], aNewVerts[ 1], // T2
        3:  916:	 aNewVerts[10], aNewVerts[11], aNewVerts[14], // T3
        3:  917:	 aNewVerts[10], aNewVerts[14], aNewVerts[13], // T4
        3:  918:	 aNewVerts[11], aNewVerts[12], aNewVerts[14], // T5
        3:  919:	 aNewVerts[12], aNewVerts[ 2], aNewVerts[14], // T6
        3:  920:	 aNewVerts[12], aNewVerts[ 9], aNewVerts[ 1], // T7
        3:  921:	 aNewVerts[12], aNewVerts[ 1], aNewVerts[ 2], // T8
        3:  922:	 aNewVerts[ 9], aNewVerts[10], aNewVerts[12], // T9
        3:  923:	 aNewVerts[10], aNewVerts[11], aNewVerts[12], // T10
        3:  924:	 aNewVerts[ 1], aNewVerts[13], aNewVerts[14], // T11
        3:  925:	 aNewVerts[ 1], aNewVerts[14], aNewVerts[ 2], // T12
        3:  926:	 aNewVerts[ 1], aNewVerts[10], aNewVerts[14], // T13
        3:  927:	 aNewVerts[ 1], aNewVerts[12], aNewVerts[14], // T14
        3:  928:	 aNewVerts[ 1], aNewVerts[10], aNewVerts[12], // T15
        3:  929:	 aNewVerts[14], aNewVerts[10], aNewVerts[12], // T16
        3:  930:	 aNewVerts[ 5], aNewVerts[ 1], aNewVerts[13], // T17
        3:  931:	 aNewVerts[ 8], aNewVerts[ 5], aNewVerts[13], // T18
        3:  932:	 aNewVerts[14], aNewVerts[ 8], aNewVerts[13], // T19
       61:  933:	 aNewVerts[ 5], aNewVerts[ 6], aNewVerts[ 8]}; // T20
        -:  934:      
        -:  935:      iBase_EntityHandle aQuadVerts[] = 
        4:  936:	{aNewVerts[ 0], aNewVerts[ 1], aNewVerts[ 5], aNewVerts[ 4], // Q1
        4:  937:	 aNewVerts[ 1], aNewVerts[ 2], aNewVerts[ 6], aNewVerts[ 5], // Q2
        4:  938:	 aNewVerts[ 2], aNewVerts[ 3], aNewVerts[ 7], aNewVerts[ 6], // Q3
        4:  939:	 aNewVerts[ 3], aNewVerts[ 0], aNewVerts[ 4], aNewVerts[ 7], // Q4
        4:  940:	 aNewVerts[ 0], aNewVerts[ 1], aNewVerts[ 2], aNewVerts[ 3], // Q5
        4:  941:	 aNewVerts[ 4], aNewVerts[ 5], aNewVerts[ 6], aNewVerts[ 7], // Q6
        4:  942:	 aNewVerts[ 1], aNewVerts[14], aNewVerts[ 8], aNewVerts[ 5], // Q7
       29:  943:	 aNewVerts[14], aNewVerts[ 2], aNewVerts[ 6], aNewVerts[ 8]}; // Q8
        -:  944:
        -:  945:      iBase_EntityHandle aNewTris[21], aNewQuads[8];
        -:  946:      // First create one tri
        -:  947:      iMesh_createEnt(new_instance, iMesh_TRIANGLE, aTriVerts, 3,
        1:  948:		      &(aNewTris[0]), &CStat, &err);
        1:  949:      if (err != iBase_SUCCESS) {
    #####:  950:	cout << "     Can't seem to create faces from verts." << endl;
        -:  951:	break;
        -:  952:      }
        1:  953:      qBuiltRegions = true;
        -:  954:
        1:  955:      TEST2(CStat == iBase_NEW && err == iBase_SUCCESS, 
        -:  956:	    "creating tri from verts");
        -:  957:
        -:  958:      // Now do it again
        -:  959://       iMesh_createEnt(new_instance, iMesh_TRIANGLE, aTriVerts, 3,
        -:  960:// 		      &(aNewTris[0]), &CStat, &err);
        -:  961://       TEST2((CStat == iBase_ALREADY_EXISTED || CStat == iBase_CREATED_DUPLICATE)
        -:  962:// 	    && err == iBase_SUCCESS,
        -:  963:// 	    "duplicate creation of a face");
        -:  964://       if (CStat == iBase_CREATED_DUPLICATE) 
        -:  965:// 	cout << "Created a duplicate face" << endl;
        -:  966:
        -:  967:      // Now use the array call for the rest
        -:  968:      {
        1:  969:	int alloc = 20, size = 0;
        1:  970:	int *status_arr, status_alloc = 0, status_size;
        1:  971:	iBase_EntityHandle* tempEntPtr = aNewTris+1;
        -:  972:	iMesh_createEntArr(new_instance, iMesh_TRIANGLE, aTriVerts+3, 60,
        -:  973:			   &tempEntPtr, &alloc, &size, 
        1:  974:			   &status_arr, &status_alloc, &status_size, &err);
        1:  975:	bool qOK = true;
        1:  976:	TESTEQ(status_size, size);
        1:  977:	TESTEQ(size, 20);
       21:  978:	for (int ii = 0; ii < size; ii++) {
       20:  979:	  qOK = qOK && status_arr[ii] == iBase_NEW;
        -:  980:	}
        1:  981:	TEST2(qOK, "creating triangles using array call");
        1:  982:	UT_FREE(status_arr);
        -:  983:      }
        -:  984:
        -:  985:      // Use an array call for the quads
        -:  986:      {
        1:  987:	int alloc = 8, size = 0;
        1:  988:	int *status_arr, status_alloc = 0, status_size;
        1:  989:	iBase_EntityHandle* tempEntPtr = aNewQuads;
        -:  990:	iMesh_createEntArr(new_instance, iMesh_QUADRILATERAL, aQuadVerts, 32,
        -:  991:			   &tempEntPtr, &alloc, &size, 
        1:  992:			   &status_arr, &status_alloc, &status_size, &err);
        1:  993:	bool qOK = true;
        1:  994:	TESTEQ(status_size, size);
        1:  995:	TESTEQ(size, 8);
        9:  996:	for (int ii = 0; ii < size; ii++) {
        8:  997:	  qOK = qOK && status_arr[ii] == iBase_NEW;
        -:  998:	}
        1:  999:	TEST2(qOK, "creating quads using array call");
        1: 1000:	UT_FREE(status_arr);
        -: 1001:      }
        -: 1002:
        -: 1003:      // Check that the number of total entities is correct.
        1: 1004:      vTestEntityCounts(new_instance, localRootSet, 35, 21, 8, 0, 0, 0, 0);
        -: 1005:
        1: 1006:      if (a2iAdjTable[2][3] == iBase_ALL_ORDER_1 ||
        -: 1007:          a2iAdjTable[2][3] == iBase_ALL_ORDER_LOGN ||
        -: 1008:          a2iAdjTable[2][3] == iBase_ALL_ORDER_N) {
        -: 1009:        // Region->face connectivity data:
        -: 1010:        iBase_EntityHandle aTetFaces[] = 
        4: 1011:          {aNewTris[ 1], aNewTris[15], aNewTris[ 7], aNewTris[ 9],
        4: 1012:           aNewTris[ 3], aNewTris[ 5], aNewTris[16], aNewTris[10],
        4: 1013:           aNewTris[13], aNewTris[ 4], aNewTris[ 2], aNewTris[11],
        4: 1014:           aNewTris[ 8], aNewTris[ 6], aNewTris[14], aNewTris[12],
       17: 1015:           aNewTris[13], aNewTris[16], aNewTris[14], aNewTris[15]};
        -: 1016:
        -: 1017:        iBase_EntityHandle aPyrFaces[] =
        4: 1018:          {aNewTris[11], aNewTris[19], aNewTris[18], aNewTris[17],
        5: 1019:           aNewQuads[6]};
        -: 1020:
        -: 1021:        iBase_EntityHandle aPrismFaces[] = 
        4: 1022:          {aNewQuads[1], aNewQuads[6], aNewQuads[7], aNewTris[12],
        5: 1023:           aNewTris[20]};
        -: 1024:
        -: 1025:        iBase_EntityHandle aHexFaces[] =
        4: 1026:          {aNewQuads[0], aNewQuads[1], aNewQuads[2], aNewQuads[3], 
        5: 1027:           aNewQuads[4], aNewQuads[5]};
        -: 1028:
        -: 1029:        iMesh_createEnt(new_instance, iMesh_TETRAHEDRON, aTetFaces, 4,
        1: 1030:                        &(aNewRegions[0]), &CStat, &err);
        1: 1031:        if (err != iBase_SUCCESS) {
    #####: 1032:          cout << "     Can't seem to create regions from faces." << endl;
        -: 1033:          break;
        -: 1034:        }
        -: 1035:
        5: 1036:        for (int ii = 1; ii < 5; ii++) {
        -: 1037:          iMesh_createEnt(new_instance, iMesh_TETRAHEDRON, aTetFaces+4*ii, 4,
        4: 1038:                          &(aNewRegions[ii]), &CStat, &err);
        4: 1039:          TEST2(CStat == iBase_NEW && err == iBase_SUCCESS, 
        -: 1040:                "creating tet from faces");
        -: 1041:        }
        -: 1042:
        -: 1043:        iMesh_createEnt(new_instance, iMesh_PRISM, aPrismFaces, 5,
        1: 1044:                        &(aNewRegions[6]), &CStat, &err);
        1: 1045:        TEST2(CStat == iBase_NEW && err == iBase_SUCCESS, 
        -: 1046:              "creating prism from faces");
        -: 1047:
        -: 1048:        iMesh_createEnt(new_instance, iMesh_PYRAMID, aPyrFaces, 5,
        1: 1049:                        &(aNewRegions[5]), &CStat, &err);
        1: 1050:        TEST2(CStat == iBase_NEW && err == iBase_SUCCESS, 
        -: 1051:              "creating pyr from faces");
        -: 1052:
        -: 1053:        iMesh_createEnt(new_instance, iMesh_HEXAHEDRON, aHexFaces, 6,
        1: 1054:                        &(aNewRegions[7]), &CStat, &err);
        1: 1055:        TEST2(CStat == iBase_NEW && err == iBase_SUCCESS, 
        -: 1056:              "creating hex from faces");
        -: 1057:
        -: 1058:      // Check that the number of total entities is correct.
        1: 1059:      vTestEntityCounts(new_instance, localRootSet, 35, 21, 8, 5, 1, 1, 1);
        -: 1060:
        -: 1061:        // Delete the pyramid.  Do its unshared faces disappear, too?
        1: 1062:        iMesh_deleteEnt(new_instance, aNewRegions[5], &err);
        1: 1063:        TEST2(err == iBase_SUCCESS, "deleting a region");
        -: 1064:      }
        -: 1065:
        1: 1066:      if (a2iAdjTable[2][2] == iBase_AVAILABLE) {
        -: 1067:	// Shouldn't be able to delete a face that has a region adjacent
        -: 1068:	// to it.
        1: 1069:	iMesh_deleteEnt(new_instance, aNewTris[5], &err);
        1: 1070:	TEST2(err==iBase_FAILURE, 
        -: 1071:	      "Oops: deleted a face with adjacent regions!");
        -: 1072:      }
        -: 1073:
        -: 1074:      // Also shouldn't be able to delete vertices.
        1: 1075:      iMesh_deleteEnt(new_instance, aNewVerts[0], &err);
        1: 1076:      TEST2(err==iBase_FAILURE, 
        -: 1077:	    "Oops: deleted a vertex with adjacent entities!");
        -: 1078:
        -: 1079:      // The following test is in a gray area of the spec:  should those
        -: 1080:      // orphaned triangular faces be deleted?  Right now, that isn't
        -: 1081:      // specified either way.
        -: 1082://       // Check that the number of total entities is correct.
        -: 1083://       vTestEntityCounts(new_instance, localRootSet, 33, 18, 8, 5, 0, 1, 1);
        1: 1084:      iMesh_dtor(new_instance, &err);
        -: 1085:    } while(0); // Target for a break from creating faces from verts
        -: 1086:		// and/or regions from faces.
        1: 1087:    TEST2(qBuiltRegions, "couldn't build regions from verts or faces");
        -: 1088:  }
        1: 1089:  CHECK_ERR(err);
        3: 1090:}
