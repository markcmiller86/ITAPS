<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ITAPS: Resilient and Non-Resilient Iterators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="resilient">Resilient and Non-Resilient Iterators </a></h1><p>A resilient iterator is one that can deal with modifications to the container it is iterating over.</p>
<p>A common concern about an iterator is how it behaves when the container over which it is iterating is modified. For example, in STL, iterators for std::set&lt;&gt; and std::map&lt;&gt; and std::list&lt;&gt; containers are guaranteed to <em>work</em> in the presence of modifications to the associated containers with one exception; they don't handle the case when the container member the iterator is currently pointed at is deleted. However, iterators for std::vector&lt;&gt; are not guaranteed to work under any kinds of modification.</p>
<p>In the ITAPS interfaces, a <em>resilient</em> iterator is one that makes certain guarantees (described below) about how it behaves when the container being iterated is modified. On the other hand, a <em>non-resilient</em> is one that does not make such guarantees.</p>
<p>In all cases, the <em>container</em> associated with an iterator in the ITAPS interfaces is an entity set of some sort. This is the only container type for which iterators are defined.</p>
<p>Here, we characterize the behavior of iterators in the presence of container modifications. There are a number of (subtle) aspects to keep in mind.</p>
<p>1. There are set-type (<em>duplicate preventing</em>) sets and list-type (<em>order preserving</em>) sets and iterators behave differently for each.</p>
<p>2. Sets can have <em>set</em> members and <em>entity</em> members. However, iterators are currently defined to iterate over <em>only</em> the entity members. That said, the question arises as to whether modifications that involve only set members nonetheless <em>effect</em> iterator behavior.</p>
<p>3. There are array-type iterators that upon each step in the iteration return a whole array of entity member handles and single entity iterators that upon each step return just a single entity member handle.</p>
<p>4. The iterators support type/topology <em>filtering</em>. Iterators do not (always) strictly iterate over <em>all</em> entities in a set; just <em>all</em> entities matching the type/topology criteria. When type/topology specifies either all types or all topologies, then indeed the iterator will iterate over all entities.</p>
<p>5. There are add/remove operations that add/remove <em>entity members</em> or <em>set members</em> to a set.</p>
<p>6. There are create/delete operations that create and delete <em>entities</em> from the whole iMesh_Instance.</p>
<p>7. There are create/destroy operations that create and destroy <em>sets</em> from the whole interface instance.</p>
<p>8. There is the <em>root set</em> which is special and may have different iterator behavior than all other sets. By definition, the root set is a set-type (<em>duplicate prevent</em>) set.</p>
<p>Modification means addition/removal and/or create/destroy and/or create/delete <em>after</em> iterator initialization. When we talk about <em>container modification</em> here, we are talking about any of the following operations.</p>
<p>A. addition and removal of entity members </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> <a class="code" href="group__EntitySets.html#gac00e7cf0fb85976301ae8635e1ef844b" title="Remove an entity from a set.">iMesh_rmvEntFromSet</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
 <span class="keywordtype">void</span> <a class="code" href="group__EntitySets.html#ga14ceb1d85e28e22a52f3df0b6e8d938a" title="Remove an array of entities from a set.">iMesh_rmvEntArrFromSet</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
 <span class="keywordtype">void</span> <a class="code" href="group__EntitySets.html#ga3dfae4b555d968744428e9b21d087440" title="Add an entity to a set.">iMesh_addEntToSet</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
 <span class="keywordtype">void</span> <a class="code" href="group__EntitySets.html#ga9b706668d662ed50aeb4e1483709c873" title="Add an array of entities to a set.">iMesh_addEntArrToSet</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
</pre></div><p> B. addition and removal of set members </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> <a class="code" href="group__EntitySets.html#gad6c792d5c60aee48658a7c9299b68b35" title="Remove an entity set from a set.">iMesh_rmvEntSet</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
 <span class="keywordtype">void</span> <a class="code" href="group__EntitySets.html#gaca90b20d6db5d383b737eb4c3750ba5a" title="Add an entity set to a set.">iMesh_addEntSet</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
</pre></div><p> C. deletion of entities from whole iMesh_Instance </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> <a class="code" href="group__Entities.html#ga9b34843000571f5094298d483a45ed21" title="Delete specified entities.">iMesh_deleteEntArr</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
 <span class="keywordtype">void</span> <a class="code" href="group__Entities.html#ga98f1c9d37ee6f7bf0795dda50d3b28f1" title="Delete specified entity.">iMesh_deleteEnt</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
</pre></div><p> D. creation of entities (effects root set) </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> <a class="code" href="group__EntitySets.html#ga5c011a4d7805b8c61aafaa5a121ff7a0" title="Create an entity set.">iMesh_createEntSet</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
 <span class="keywordtype">void</span> <a class="code" href="group__VertexEntities.html#ga8596670832ac7365496ac586e85a2a11" title="Create an array of new vertices at specified coordinates.">iMesh_createVtxArr</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
 <span class="keywordtype">void</span> <a class="code" href="group__Entities.html#ga817380ba91d5fff1fe0e656982f0375e" title="Create an array of new entities with specified lower-order topology.">iMesh_createEntArr</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
 <span class="keywordtype">void</span> <a class="code" href="group__VertexEntities.html#ga28f79a4c8c445804215a751563c26688">iMesh_createVtx</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
 <span class="keywordtype">void</span> <a class="code" href="group__Entities.html#ga27772c2a82d0cb1244e3107238f28d7e" title="Create a new entity with specified lower-order topology.">iMesh_createEnt</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
</pre></div><p> E. destruction of entity sets </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> <a class="code" href="group__EntitySets.html#ga096ca8e137fa3149d303935839e09c94" title="Destroy an entity set.">iMesh_destroyEntSet</a>(<a class="code" href="group__Datatypes.html#gacb65e940120fe27aa9c62210e5a8fad4" title="iMesh instance">iMesh_Instance</a> instance,
</pre></div><p>By container modification, we mean that of the above operations occur on the container between iterator initialization and reset.</p>
<p>For purposes of this discussion, there is no distinction between any of these <em>kinds of</em> modifications. What is true for any is true for all. Below, the words <em>add</em> and <em>remove</em> are used to represent any of the modifications that add members or remove members regardless of the <em>kind of operation</em> above.</p>
<p>Resilient iterators are not effected by modifications involving set members:</p>
<p>Iterators are currently defined to iterate over *only* the entity members of a container. In particular, if the container is modified by adding/removing sets from the container, this will have no impact on the iterator. This is true for set-type sets and list-type sets.</p>
<p>Resilient iterator's <em>current position</em> not effected by modification:</p>
<p>If the container is modified, the iterator will continue to properly <em>keep track of</em> the member it was currently pointing at. If a modification occurs that removes the member it was currently pointing at, the iterator will be advanced to the <em>next</em> (not already deleted) member it would have proceeded to. In this way, the iterator is guaranteed to always point at a valid member or to the end of the set, in the case that the member being removed is the last one.</p>
<p>A resilient iterator must skip over removed members:</p>
<p>If the container is modified by removing members, the iterator will guarantee not to <em>land on</em> (e.g. return) those members as iteration proceeds. This is true of set-type sets and list-type sets.</p>
<p>A resilient iterator on set-type sets <em>may</em> fail to return added members:</p>
<p>If the container is a set-type (<em>duplicate preventing</em>) container and it is modified by adding members, the iterator <em>may</em> skip over (e.g. fail to return) members that have been added. In other words, there is no guarantee in this circumstance that an iterator will return added members.</p>
<p>A resilient iterator on list-type sets <em>must</em> return added members. If it is a list-type (<em>order preserving</em>) container, then the iterator <em>must</em> guarantee to return the added members.</p>
<p>A non-resilient iterator may or may not behave like a resilient iterator in some or all of the circumstances described above. There are no guarantees about how a non-resilient iterator will behave. The behavior of a non-resilient iterator in the presence of container modifications is left entirely up to the implementation.</p>
<p>If upon initializing an iterator, an application requests it be resilient and the implementation is unable to support that, the iterator initialization request shall fail and return error iBase_NOT_SUPPORTED. </p>
</div>
<hr size="1"><address style="align: right;"><small>
Generated on Tue Mar 20 19:49:14 2012 for ITAPS-1.4 &nbsp;<a href="http://www.itaps.org"><img src="ITAPSLogo.jpeg" alt="ITAPS" align="middle" border="0"></a></small></address>
</body>
</html>
