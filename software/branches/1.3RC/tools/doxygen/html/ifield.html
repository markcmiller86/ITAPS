<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ITAPS: iField: ITAPS Field Interface</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<h1><a class="anchor" name="ifield">iField: ITAPS Field Interface</a></h1><h2><a class="anchor" name="INTRO">
Overview</a></h2>
The iField interface is intended to provide support for tensor fields and collections of tensor fields, with a strong bias towards supporting first and best the capabilities required for scientific computing applications.<p>
Scientific computing applications deal in physical quantities expressed as tensors: scalars such as temperature, vectors such as velocity, and second-order tensors such as stress. In practice, these are formally tensor fields: a tensor field assigns a tensor to each point in a mathematical space (typically a Euclidean space or manifold).<p>
Because tensors have a geometric interpretation, their underlying physical meaning is independent of the coordinate system in which they are defined; the numerical value of a tensor depends on the coordinate system, and so any numerical instantiation of a tensor field is incomplete without a specification of its coordinate system.<p>
The ITAPS Field interface represents a field as a linear combination of distribution functions and degrees of freedom (dof's): ${i} w_{i} f_{i} ({x})$. For typical discrete fields, the distribution functions $f_{i}$ have compact support over a single highest-dimensional mesh entity, and are each more or less associated with a mesh entity, which may be of lower dimension; for instance, the interpolation functions used in the finite element method may be associated with a vertex, edge, face, or region. These distribution functions are known in advance. The degrees of freedom $w_{i}$ are associated with both an entity and a distribution function; calculation of these degrees of freedom is the goal of a typical scientific computing application.<p>
An ITAPS Field is, for practical purposes, a function. The representation of the function will, in most use cases, be piecewise and will not necessarily by continuous (never mind smooth), but with reasonable definitions in a few tight spots, a Field is in fact a function.<p>
In addition to supporting physical tensor fields, there's a reasonable argument for allowing integer or boolean values for fields. While these don't represent physical tensors, and need to be restricted to scalars (coordinate transforms for vectors of booleans, anyone?), applications do and will continue to want to use such things. This case implies certain restrictions on distribution functions for integer and boolean scalar "fields" and on the operations one can perform on them.<p>
To support this representation of Fields and the sorts of operations on Fields that applications require, we need precise definitions of the domain of a function, of the data that a Field represents, and of how we relate the domain and range for a Field.<h2><a class="anchor" name="ADM">
Abstract Data Model</a></h2>
<h3><a class="anchor" name="DOM">
Domain</a></h3>
<h4><a class="anchor" name="Preliminary">
Definitions</a></h4>
Primitive SET (pSET) An infinite point set corresponding, topologically, to an iMesh or iGeom Entity.<p>
Examples:<p>
iMesh_TRIANGLE iMesh_HEXAHEDRON<p>
The key feature of a pSET is its topology and the adjacency information implied by, for instance, knowing the identities of the faces, edges, and vertices on the closure of a region. Geometric information (locations of vertices, shapes of higher-dimensional entities) is a separate matter.<p>
Pre-Domain: The union of a collection of primitive point sets; that is, an iMesh or iGeom EntitySet.<p>
A pre-domain is a topological description of the domain; specifically, it has no coordinates associated with it to define the spatial location of iMesh and iGeom Entities. It represents an infinite point set on which the field will be defined, decomposed into iMesh/iGeom primitives (pSETs) with adjacency information to knit those pSETs together to cover the infinite point set.<p>
Domain (mesh based)<p>
The domain of a field is expressed, at the lowest level, by a collection of mesh entities over which the field is defined. This collection can potentially be expressed in multiple ways: as the entities in an iMesh entity set (in many use cases, the root set) or as the mesh entities related (by iRel) to one or more iGeom entities.<p>
Loose coupling between mesh topology and geometry is a benefit in several cases --- including mesh smoothing/relaxation, shape optimization, and deforming domain problems. This suggests that some cooperation between iMesh and iField is ideal for handling coordinates, with some cases handled strictly through iMesh, others strictly through iField, and some jointly.<p>
For practical reasons, the iMesh specification defines one very important field; the coordinate field. In addition, the iMesh specification defines only the most common coordinate field representation; a piecewise linear, Lagrange field. Support for more sophisticated coordinate fields will be possible but only through iField, not through iMesh's 'native' coordinate field representation.<p>
When a new mesh is instantiated, an iMesh client will indicate if the mesh will employ iMesh's 'native' coordinate field representation or not via a new boolean argument to <a class="el" href="group__Initialization.html#gd2c9498620bc73c9e4f405ce9f6806de">iMesh_newMesh()</a><p>
void iMesh_newMesh( const char *options, Pointer to implementation-specific options string int lagrange_coords, flag indicating if iMesh' lagrange coordinates will be used iMesh_Instance *instance, Pointer to iMesh instance handle returned from function int *err, Pointer to error type returned from function int options_len Length of the character string pointed to by options );<p>
If 'int lagrange_coords' is zero (false)...<p>
that means the coordinate field for the mesh will be handled through iField. In this case, the iMesh implementation is free to do whatever it wishes with coordinate values passed via createVtx calls including ignoring that data entirely and not even storing it. Calls to either iMesh_getVtxArrCoords or iMesh_getVtxCoord will return no coordinate data and set the err return to iBase_NO_LAGANGE_COORDS. Calls to iMesh_setVtxArrCoords and <a class="el" href="group__VertexEntities.html#g3ed834cf7634a40abb898411f698f99c">iMesh_setVtxCoord()</a> will make no attempt to interpret coordinate data passed in and will likewise return err set to iBase_NO_LAGANGE_COORDS. Calls to iMesh_createVtxArr and iMesh_createVtx will make no attempt to interepret coordinate data passed in (e.g. will not attempt to de-reference pointers to coordinate values), but will return iBase_SUCCESS.<p>
Note, even if iField is later used to define a coordinate field that is in fact a piecewise-linear, lagrange coordinate field for the mesh, there will be no obligation that that fields dofs make its way into the iMesh mesh instance such that it be managed by iMesh as it otherwise ordinarily would have.<p>
Otherwise, 'int lagrange_coords' is non-zero (true) and...<p>
that means the coordinate field for the mesh will be handled BOTH through iMesh AND through iField. By 'BOTH', here that does not mean that data is redundantly stored. It only means that it is redundantly accessible through set/getVtx methods in iMesh as well as set/getDof methods in iField. For some implementations, this will require a different access/storage method for this particular type of coordinate field than for other fields.<h3><a class="anchor" name="TENSOR">
Representing Tensor Data</a></h3>
Tensor Templates<p>
A tensor template is intended to define all of the information about a physical tensor that is dependent only on the physical quantity being represented. For instance, a 3D velocity vector is always a 3-vector of real numbers and represents a length/time. A 2D stress tensor is always a 2nd-order tensor (2x2) of real numbers and represents a force/area (mass-length/(time^2 length^2)). Electric field is a 3D vector of real numbers and represents a force/unit charge. These statements will be true for any 3D velocity or 2D stress or 3D electric field, regardless of system of units, coordinate system, precision of stored values, etc.<p>
Important things to know about a tensor template<p>
Tensor order (integer) 0 for scalars, 1 for vectors, 2 for tensors mapping one vector to another, etc.<p>
Number of tensor components (integer) Is this a 2-vector, a 3-vector, etc.<p>
Algebraic type (enumeration) This describes the rules for combining values and/or the range of legal values. For instance, real numbers, complex numbers, barycentric coordinate vectors, and quaternions all have different algebraic rules.<p>
Quantity (handle) See definition later in this document.<h3><a class="anchor" name="DFUNC">
Distribution Functions on Meshes</a></h3>
At this stage, the focus is on making the easy things easy. The easiest case for distribution functions on meshes is the case where each entity has the same set of distribution functions; that is, the case in which the field representation is the same for every highest (topological) dimensional entity. Note that this does not preclude things like linear elements for pressure and quadratic for velocity (these are, after all, different fields and can have different dfuncs). Nor does this preclude things like edge-based elements: these split a typical shape function over multiple regions (as do other continuous FE methods). Note also that the definition refers to the highest TOPOLOGICAL dimension entity: this implies that a field can be defined over a collection of faces (say, all or part of a boundary), with dfuncs defined over the faces.<p>
Distribution functions and their derivatives will be hard-coded in a distribution function kernel (DFK), which will contain all information required to evaluate all distribution functions (and their gradients, etc) for that highest-dimensional entity (HDE). In practice, this takes the form of a callback from the implementation to some external distribution function kernel, which will evaluate a specified dfunc (one of perhaps many for the HDE) as a specified location in a specified entity.<p>
In this scenario, each distribution function (dfunc) has support over exactly one highest (topological) dimensional entity; one or more distribution functions (dfuncs) can be have the same highest-dimensional entity as their support. Each distribution function has exactly one degree of freedom (dof) associated with it per tensor component. The dfunc and dof may be associated directly with a vertex, edge, or face instead of a region (think high-order FE). The dofs and dfuncs must have a common ordering, dictated by the DFK and understood by the application. The implementation needs only to know how to call the DFK callback and sum dof*dfunc value at a point.<p>
As a practical matter, it is obviously very important to know how to convert global coordinates into local coordinates and vice versa, as the dfuncs will necessarily have to use local coordinates. Obvious choices like barycentric and shifted cartesian coordinates could be specified in an enum, but the current API anticipates that there will be a wide and weird enough range of local coordinate systems that it makes sense for the DFK to include functions for coordinate conversion in both directions, as well as the Jacobian of the transformation.<p>
The More General Case<p>
More generally, it's often desirable to define distribution functions that are not associated with highest-dimensional entities, or that are have a support that extends beyond a single HDE. Examples of this include vertex-centered finite-volume schemes (dfunc associated with a vertex, with support over parts of all regions incident on that vertex), spectral-like methods, and filtering or convolution kernels. Although details have not yet been worked out, the interface for supporting these types of DFK's is likely to bear some syntactic and semantic resemblence to the iMeshP ghost descriptions.<p>
Examples (all dof counts for tets at this point...)<p>
Galerkin FE (quadratic) One dof/vertex, one dof/edge, zero dof/face, zero dof/region. Local coordinates: barycentric. Code for 10 dfuncs (standard shape functions) must be provided.<p>
Discontinuous Galerkin (cubic) Zero dof/vertex, zero dof/edge, zero dof/face, twenty dof/region. Local coordinates: barycentric. Code for 20 dfuncs (standard shape functions) must be provided.<p>
Cell-centered FV (quadratic) Zero dof/vertex, zero dof/edge, zero dof/face, 10 dof/region. Local coordinates: cartesian w/ origin at centroid. Code for 10 dfuncs (monomials) must be provided.<p>
Vertex-centered FV (quadratic) 10 dof/vertex, zero dof/edge, zero dof/face, zero dof/region. Local coordinates: cartesian w/ origin at vertex(?), plus a filter function that selects which vertex-centered control volume that covers part of a region the point actually falls into (filter function uses local barycentric coords). Code for 10 dfuncs (monomials) must be provided. Note: this is a bit of a hack; in practice most field evals that a solver does are already pre-identified with a CV. This is a case that cries out for a more sophisticated approach to defining support of dfuncs.<h3><a class="anchor" name="Tensor">
Field</a></h3>
A tensor field is an intermediate step in instantiating a tensor template: at this level, units, data precision, a type for physical coordinates, a distribution function kernel and a domain are added.<p>
Units (handle) See definition later in this document.<p>
Coordinate type (enum): Possible values include cartesian, cylindrical, and spherical. This is critical for tensor transformations.<p>
DFK See above.<p>
Data precision. This identifies whether floating point data is stored in single, double, or quad precision. This enumeration may need to be expanded.<p>
Domain<p>
In addition to fields that describe single physical tensors, it is often convenient in scientific computing to have multiple tensor fields stored and accessed together. For instance, in incompressible flow, a vector velocity and scalar pressure are both required, and often stored interleaved (uvwPuvwP...) to improve cache hit rates. To support this common usage --- including making it relatively easy for implementations to store variables together --- the iField API includes a function to create a collection of tensor fields together as well as an overall field that acts as a container for these multiple tensors. In a possible abuse of the data model, these compound fields use the same data type as regular tensor fields; implementations are required to be able to distinguish between the two. Some queries for a tensor field can not be reasonably answered for a compound field; these cases are noted in the API spec.<p>
Glossary<p>
Coordinate system How space is laid out and measured. A coordinate system may be local or global, and either may be physical or parametric. Common examples will surely include cartesian, polar, spherical, and barycentric coordinates. User-defined coordinate systems can be infinite in variety, obviously. Each coordinate field will be associated with a coordinate system; a coordinate system can apply to many coordinate fields. More on this when coordinate fields come into the interface in earnest.<p>
Key functionality: conversion to/from cartesian, plus producing the metric and Jacobian info required for differentiation and integration.<p>
Quantity Measurable physical property of phenomena/bodies/substances.<p>
Examples: mass, length, time, acceleration, volume, power, force, illuminance<p>
Any Quantity can be expressed in terms of the seven basic physical quantities, corresponding to the seven base units of the SI system: mass, length, time, temperature, electric charge, luminous intensity and amount of substance. A Quantity has the following data<p>
(required) int[7] num_powers; Powers of 7 basic quantities in numerator<p>
(required) int[7] den_powers; Powers of 7 basic quantities in denominator<p>
(required) int flags; bool bits to indicate e.g. intensive/extensive, conserved, etc.<p>
(optional) char *name; name of quantity<p>
(optional) char *abbr; abbreviation of quantity.<p>
Operations: 7 basic quantities are pre-defined and guaranteed to always exist. New, derived, quantities are defined by multiplying together old ones.<p>
Notes:<p>
It useful to distinguish a quantity representing a mass fraction (e.g. mass/mass) from a quantity representing a volume fraction (e.g. volume/volume) for example.<p>
Essentially there are two kinds of quantities; base quantities and derived quantities. Base quantities are, by necessity, defined by the data model specification itself and are guaranteed to exist. Derived quantities shall be definable by applications as necessary. See physics.nist.gov/cuu/Units/units.html for detailed discussion.<p>
Unit An adopted convention for assigning a numerical value to a Quantity. A Unit has<p>
(required) handle quant; the Quantity the unit is a measure for<p>
(required) double scale; scale of this unit relative to the default unit of measure for quant.<p>
(optional) double offset; likewise for offset units<p>
(optional) double logbase; likewise for log-related units<p>
(optional) double logcoef; likewise for log-related units<p>
(optional) char *name;<p>
(optional) char *abbr;<p>
Examples:<p>
slug is a unit of measure of the quantity mass<p>
pound is a unit of measure of the quantity force<p>
minute is a unit of measure of the quantity time<p>
meters/second is a unit of measure of the quantity velocity<p>
furlongs/fortnight is a unit of measure of the quantity velocity<p>
decibels is a (log scaled) unit of measure of the quantity power.<p>
degrees Fahrenheit is a (offset) unit of measure of the quantity thermodynamic temperature.<p>
Operations:<p>
Associate a Unit (of measure) with a Quantity<p>
Combine Unit A and Unit B producing new Unit C by scale factor and optional power.<p>
Set log and/or offset scaling of Unit A relative to Unit B<p>
Unit System A collection of quantities together with default units for them. A Unit System has<p>
(required) handle bunits[7]; default units for 7 base quantities.<p>
(optional) char *name; name of this unit system<p>
(optional) handle dunits*; default units for any derived quantities that are NOT deriveable from bunits.<p>
Examples:<p>
International System of Units (SI) is an example of a system of units where default units for base quantities are meters, kilograms, seconds, amperes, kelvin, mole, candela. From these, derived units for velocity, for example, meters/second, current density, amperes/meter^2, etc.<p>
A and B Divisions at LLNL use default units such as 10 nanoseconds for time, centimeters for length, etc.<p>
Notes: If in a given iMesh/iField instance we ever wind up mixing field objects created by different applications, then it is very likely going to be necessary to be able to explicitly set units for any given field (e.g. use something other than the default determined by some Unit System). This will be especially true if in any given iMesh/iField instance we support only one 'active' Unit System.<p>
It might be nice to allow applications to refer to systems of units by name rather than having to create them from scratch as needed.<h2><a class="anchor" name="Other">
Notes and Comments</a></h2>
MCM: 'Precision' is potentially confusing here, particularly since this list is not either all floating point formats or all integer formats. Shouldn't this list really come out of iBase anyways and/or shouldn't we extend iBase to include types needed by iField?<p>
MCM: The notion expressed here seems to be a kind of hybrid of the data type as well as operations it supports. None of these are really algebraic types in the sense that I introduced that term for this API.<p>
Though I see the possible value in distinguishing between dofs obeying boolean algebra semantics and those obeying say complex number semantics, that isn't what I had originally introduced the notion of algebraic type to support.<p>
At the same time, we're missing entirely the notion of vector valued and tensor valued fields here as well as 'scalar' which all the examples below are really instances of certain classes of algebraic types of 'scalar'.<p>
If it was just a matter of distinguishing between scalar, vector and tensor type things, we'd simply declare all fields to be 'tensor valued' and just specify the tensor order (which we do anyways). But, that then misses the nuances of integral valued vs. real valued vs. complex valued (what about integral-complex? digital signal processing codes have to deal with this issue).<p>
Also, for something like 'complex', that involves 2 things, not one. And, those things could be real-imaginary pairs (cartesian) or magnitude-phase pairs (polar). In other words, there is a tiny little 'coordinate system' that defines how values of the field (thats the range set of the domain-range pair of sets needed to define a function) are interpreted. For a quaternion, there would be 4 things. I mention quaternion only to help in understanding how to properly generalize and abstract this. Even for a single thing (number), there is a difference between just that number and that number multiplying a vector, say the unit X direction vector. One is a scalar, the other is a vector even though both involve only a single number, the magnitude in the X direction. In other words, 'a' is different from 'a multiplying x-hat'. The latter is what you'd call the 'component' of some vector field and that is qualitatively different from something that is truly a scalar value'd field.<p>
The issue with whether or not the values of a field take on only discrete (integral or boolean even) values is a statement about the range set (of the domain&lt;-&gt;range pair that we're defining a function between. It says whether or not the set is 'continuous' or 'discrete' as in the difference between the real number line and the integers.<p>
I think this best way to handle these notions is a slightly more complex API for defining algebraic types similar to the DFK api already being developed.<p>
CFOG reply: Mark, I don't see (at least yet) why the combination of tensor order, precision, and algebraic type doesn't cover the cases you discuss. I agree that there may be some overlap. Would be be better off keeping precision (bool, int, float, double, quad, ???) and having this variable tell us only real/complex/??? ? I think I'd prefer not to roll the two together (nearly doubling the number of precisions). In any event, all three of the pieces of info in my first sentence are going to be needed to decide on storage.<p>
Before we go making this a user-extensible kind of thing, I'd definitely want to see real, concrete use cases that aren't covered by something simple.<h2><a class="anchor" name="Define">
possible storage hints for a tensor</a></h2>
Depending on application context, the optimal way to store field data may differ. For instance, a flow solver may prefer dofs for each entity to be stored contiguously (in an array of all dofs) for efficient access while an adaptation scheme may prefer dofs to be associated directly with entities so that dofs can be created and destroyed with entities.<p>
The application can provide suggestions to an implementation about what dof storage pattern is likely to be advantageous using the values enumerated here. An implementation may or may not choose to take advantage of the hint. Either way, the implementation is still responsible for correctly responding to all iField queries.<p>
Values of the enumeration are currently iField_BLOCKED, iField_INTERLEAVED, iField_MIXED, and iField_PER_ENTITY.<p>
Block implies that a scalar temperature (T) and velocity (u,v,w) in a compound field are desired to be stored as: (TTTTTT...uuuuuu...vvvvvv...wwwwww...). For a simple velocity field, omit the T's in this example.<p>
Interleaved implies that a scalar temperature (T) and velocity (u,v,w) in a compound field are desired to be stored as: (TuvwTuvwTuvwTuvwTuvwTuvw...). For a simple velocity field, omit the T's in this example.<p>
Mixed implies that a scalar temperature (T) and velocity (u,v,w) in a compound field are desired to be stored as: (TTTTTT...uvwuvwuvwuvwuvwuvw...). For simple fields, this option is not allowed.<p>
Per entity implies that the app wants data associated with entities to support mesh modification / adaptation. (Yes, these can be supported using array-based storage, but it's harder that way.)<p>
MCM or FD: We can't support the case where a caller has 3 separate arrays one for X, one for Y and one for Z. That seems like way too common a case to NOT handle. In fact, for many rank=1 or 2 tensor fields, this is a real common storage paradigm. All we really need to do to handle this case is add iField_SEPARATE.<p>
CFOG reply: For data stored internally in the iField implementation, how does iField_SEPARATE differ functionally from iField_BLOCKED? Whether I use one array or separate arrays, I'm pretty sure that minor pointer magic in the implementation will result in identical machine code.<p>
CFOG 9/26/10 I can definitely see wanting to iterate separately over entities with different dfuncs. Should these be separate calls to create iterators, or additional args to the existing iterator calls?<p>
Also, IMO, apps are responsible for ensuring sensible behavior in the transitional cases (entities with some faces p-refined but not all, say. If nothing else, how this is dealt with depends on what dfuncs you combine, so the implementation needs guidance anyway. Caveat user.<p>
NOTES / QUESTIONS / TOPICS FOR DISCUSSION:<p>
Placeholder: At a minimum, we need to be able to represent tensor product spaces $(^{n})$ --- space-time is the most common but by no means only example. Regardless of details, this requires more thought.<p>
Placeholder: Variable order (p-refinement)<p>
Placeholder: Thread safety: atomic += and lock/unlock? Or strictly up to implementation?<p>
Placeholder: Returning mixed real / int data. Up-convert to double?<p>
Placeholder: dfunc kernel support: iBase_Type, plus indication of dual?<p>
1. Being able to express relationships between fields is a useful capability, even if iField does nothing more than store the relationship and emit it on demand. We discussed differential and algebraic operators; others are possible as well. Evaluation of these operators is something that is probably best done as a service (implementations could of course choose to implement this service directly, making operations on their own fields more efficient...). We tentatively concluded that this capability is unlikely to affect the core of the iField API and may even be orthogonal to most or all of the rest of the API.<p>
4. Coordinate consistency: I am thinking there is an argument for creating a (non-coordinate) field using a mesh topology and a coordinate field. The latter would carry info about cartesian vs. polar, etc. Physical coordinates passed to that field (and its component tensors and dfuncs, where appropriate) would be in that coordinate systems. There are some obvious advantages to enforcing coordinate system consistency in this way, but also some possible disadvantages. Any thoughts on this?<p>
5. We may want functions to be able to iterate over all dof clusters (dofs associated with the same entity) for things like changes of variables and/or coordinate system. Otherwise, you either have to retrieve all the dofs at once to do this, or duplicate work by doing the conversion (in a copy mode) multiple times for shared dofs, or keep track of which dofs you have done. <hr size="1"><address style="align: right;"><small>
Generated on Wed Jun 1 13:48:05 2011 for ITAPS-1.3 &nbsp;<a href="http://www.itaps.org"><img src="ITAPSLogo.jpeg" alt="ITAPS" align="middle" border="0"></a></small></address>
</body>
</html>
