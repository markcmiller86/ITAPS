<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>ITAPS: Saving and Loading fields to persistent storage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Saving and Loading fields to persistent storage<br/>
<small>
[<a class="el" href="group__iField.html">iField</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iField__Persistence.html#ga165166dd41f549684f312077da49caa4">iField_save</a> (const <a class="el" href="iField_8h.html#a54073ec3801454eff79fd97e1c734427">iField_Instance</a> instance, <a class="el" href="iField_8h.html#a8e68204af25e15c3dc7da993256fb7c9">iField_TensorHandle</a> tensor_handle, const char *filename, const char *options, int *err, const int filename_len, const int options_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save a Field to a file.  <a href="#ga165166dd41f549684f312077da49caa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iField__Persistence.html#gaa4f023e9a896141f02662500bbda83ce">iField_load</a> (const <a class="el" href="iField_8h.html#a54073ec3801454eff79fd97e1c734427">iField_Instance</a> instance, <a class="el" href="iField_8h.html#a8e68204af25e15c3dc7da993256fb7c9">iField_TensorHandle</a> tensor_handle, const char *filename, const char *options, int *err, const int filename_len, const int options_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a Field definitions from a file.  <a href="#gaa4f023e9a896141f02662500bbda83ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__iField__Persistence.html#ga422f7edd89ef6df97bd235fe6f3a1536">iField_loadDofs</a> (const <a class="el" href="iField_8h.html#a54073ec3801454eff79fd97e1c734427">iField_Instance</a> instance, <a class="el" href="iField_8h.html#a8e68204af25e15c3dc7da993256fb7c9">iField_TensorHandle</a> fields_whose_dofs_to_load, const char *options, int *err, const int options_len)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read dofs for (some) fields in the instance.  <a href="#ga422f7edd89ef6df97bd235fe6f3a1536"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa4f023e9a896141f02662500bbda83ce"></a><!-- doxytag: member="iField.h::iField_load" ref="gaa4f023e9a896141f02662500bbda83ce" args="(const iField_Instance instance, iField_TensorHandle tensor_handle, const char *filename, const char *options, int *err, const int filename_len, const int options_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iField_load </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="iField_8h.html#a54073ec3801454eff79fd97e1c734427">iField_Instance</a>&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="iField_8h.html#a8e68204af25e15c3dc7da993256fb7c9">iField_TensorHandle</a>&nbsp;</td>
          <td class="paramname"> <em>tensor_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>filename_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>options_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read a Field definitions from a file. </p>
<p>File format and options will inevitably be implementation dependent. Note: No actual field dofs are read into memory in this call. MCM: maintaining the binding between dofs (in iField) and entities (in iMesh) (e.g. the dof associations) involves assumptions regarding the ordering of these things in the buckets in which they are stored. iField may need to impose restrictions on what iMesh is allowed to do in the way of re-ordering things on its _save _load operations. Or, iMesh needs to deliver some permutation vector to iField so that iField can re-order its dofs to match iMesh (for those dofs that are not handled as tags). MCM: The above sounds like it is similar to the problem of how do we deal with addition/deletion of entities in iMesh? What happens to the dofs associated with those entities? I don't think we can prevail upon iMesh to inform iField that the associated dofs also need to be deleted. However, we might be able to require iField to ask the iMesh instance if the entities for which it is storing dofs have 'changed'. But even so, knowing the ordering has changed is not sufficient. iField would need to query from iMesh the new ordering and then adjust dof storage to match it. I think having call in which all this magic was buried would be helpful to the iField client. Something like... void iField_syncDofStorage(const iField_Instance instance, int *err); might be sufficient. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>instance</em>&nbsp;</td><td>iField instance handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tensor_handle</em>&nbsp;</td><td>Tensor to act on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filename</em>&nbsp;</td><td>What file to read from. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>options</em>&nbsp;</td><td>Options, probably implementation dependent. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>err</em>&nbsp;</td><td>Returned Error status (see iBase_ErrorType) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filename_len</em>&nbsp;</td><td>Length of filename string. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>options_len</em>&nbsp;</td><td>Length of options string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga422f7edd89ef6df97bd235fe6f3a1536"></a><!-- doxytag: member="iField.h::iField_loadDofs" ref="ga422f7edd89ef6df97bd235fe6f3a1536" args="(const iField_Instance instance, iField_TensorHandle fields_whose_dofs_to_load, const char *options, int *err, const int options_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iField_loadDofs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="iField_8h.html#a54073ec3801454eff79fd97e1c734427">iField_Instance</a>&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="iField_8h.html#a8e68204af25e15c3dc7da993256fb7c9">iField_TensorHandle</a>&nbsp;</td>
          <td class="paramname"> <em>fields_whose_dofs_to_load</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>options_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read dofs for (some) fields in the instance. </p>
<p>MCM: This approach assumes an impl. can allocate memory for dofs separately from the field 'header' information itself. MCM: We discussed adjusting the iField_createTensorField call to accept an option to indicate if the memory should be allocated then or deferred to later. That is basically the same idea as we are hoping to achieve here in the load call. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>instance</em>&nbsp;</td><td>iField instance handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fields_whose_dofs_to_load</em>&nbsp;</td><td>The field handles for which dofs should be loaded </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>options</em>&nbsp;</td><td>user defined options </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>err</em>&nbsp;</td><td>Returned Error status (see iBase_ErrorType) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>options_len</em>&nbsp;</td><td>length of the options string </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga165166dd41f549684f312077da49caa4"></a><!-- doxytag: member="iField.h::iField_save" ref="ga165166dd41f549684f312077da49caa4" args="(const iField_Instance instance, iField_TensorHandle tensor_handle, const char *filename, const char *options, int *err, const int filename_len, const int options_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void iField_save </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="iField_8h.html#a54073ec3801454eff79fd97e1c734427">iField_Instance</a>&nbsp;</td>
          <td class="paramname"> <em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="iField_8h.html#a8e68204af25e15c3dc7da993256fb7c9">iField_TensorHandle</a>&nbsp;</td>
          <td class="paramname"> <em>tensor_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>filename_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>options_len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Save a Field to a file. </p>
<p>There is a problem with maintaining the binding between iField and iMesh (or iGeom) persistently. In a running executable, we've got the iField and iMesh instance handles. But, when loading from disk, all we've got is filenames. Our options for maintaining iMesh&lt;-&gt;iField binding persisently are... a) Store iMesh file name in iField (perhaps reverse as well). This will probably require methods specifically for this task in both interfaces. b) Store iMesh and iField instances to the same file. This is the most natural thing to do anyways. But, I don't think we can assume all implementations are prepared to handle this so I am not sure we can make this a requirement. c) Rely upon some naming convention such that given the name of one piece, you can construct the other and vice versa. This is the simplest strategy but feels kludgy. d) Ignore the problem. Let the applications worry about it. I think this is just asking for trouble. e) A 'meta' file containing the iField/iMesh filenames. An xml-ish meta file might serve us well here. Note: the above assumes all fields are in one file. But the save call defined here doesn't necessarily REQUIRE that. Perhaps it should. If we somehow loose track of the mesh file, then all of our field data is pretty much totally useless. If this function is called multiple times for different fields in the same iField_instance what happens? Can all the data go to the same file? Must it go into different files? If think if the latter is true, we're asking for serious I/O performance problems. On the other hand, if the caller passes a different filename each time, then the impl. has no choice, either. CFOG: Checksums on iMesh file would be useful to keep to know if something goes wrong with the mesh file. Another issue is mixing, for example, a GRUMMP iMesh instance with a MOAB iField instance. There is no reason this should NOT be supported. Nonetheless, this probably does raise some issues regarding save/load operations that we've yet to consider. File format and options will inevitably be implementation dependent. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>instance</em>&nbsp;</td><td>iField instance handle </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tensor_handle</em>&nbsp;</td><td>tensor to act on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filename</em>&nbsp;</td><td>What file to write to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>options</em>&nbsp;</td><td>Options, probably implementation dependent. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>err</em>&nbsp;</td><td>Returned Error status (see iBase_ErrorType) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filename_len</em>&nbsp;</td><td>Length of filename string. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>options_len</em>&nbsp;</td><td>Length of options string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr size="1"><address style="align: right;"><small>
Generated on Tue Mar 20 19:49:14 2012 for ITAPS-1.4 &nbsp;<a href="http://www.itaps.org"><img src="ITAPSLogo.jpeg" alt="ITAPS" align="middle" border="0"></a></small></address>
</body>
</html>
