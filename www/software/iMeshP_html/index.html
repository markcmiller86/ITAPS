<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>iMeshP: Main Page</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>iMeshP Documentation</h1>
<p>
<a class="el" href="i_mesh_p_8h.html">iMeshP.h</a> -- ITAPS Parallel Mesh Interface<p>
Release 1.0; Updated April 2009<h2><a class="anchor" name="INTRO">
Overview</a></h2>
ITAPS' iMeshP interface provides functions to create, query, and modify a parallel distribution of a mesh. Our primary target for iMeshP is distributed memory applications, but the interface is also compatible with shared memory or global address space applications. In addition, backward compatibility of the serial iMesh interface is supported, with iMesh working as an application would expect within a single process, in shared memory, and in global address space systems.<p>
The iMeshP interface defines a model for partitioning the entities of a mesh among distinct processes. It describes the distribution of and relationships among entities on different processes. In the model, a partition is a high-level description of the distribution of mesh entities. A parallel communication abstraction is used to manage communication among entities and processes in a partition. A partition assigns entities to subsets called parts. The partition maps each part to a process such that each process may have zero, one, or many parts.<p>
Parts are identified globally by unique part IDs and, within a process, by opaque part handles. To simplify the iMeshP interface, we allow part handles to be substituted for entity-set handles in all serial iMesh functions. Thus, operations such as adding entities to parts and querying the number of entities in a part can be achieved using the same interface as adding entities to and querying entity sets. Additional iMeshP functions provide information about part boundaries and neighboring parts.<p>
Each entity is owned by only one part; ownership imbues the right to modify. Entities on part boundaries are shared. One part owns the entities while other part(s) have copies of the entities. Copies of additional, non-boundary entities (called ghost entities) may be requested by an application to enable efficient computation. The iMeshP data model defines rules for the amount of information about copies that an implementation must manage. For example, an entity's owner must store information about all copies of the entity, and a copy must store information about the entity's owner.<p>
Functions to easily create and modify partitions, create ghost entities, retrieve ghost and owner entity tag data, and determine an entity's ownership status are defined in iMeshP. In addition, the iMeshP interface supports parallel operations needed for efficient computation, load balancing and mesh modification. By necessity, these operations involve parallel communication; both synchronous and asynchronous parallel operations are supported. This design enables operations such as updates of tag data in ghost entities during computation, large- or small-scale entity migration for dynamic load balancing or edge swapping, updates of vertex coordinates in non-owned vertices for mesh smoothing, and coordination in the creation of new entities along part boundaries for mesh refinement.<p>
Below, we more carefully define these concepts. We also review iMesh concepts that are relevant to the iMeshP interface.<h2><a class="anchor" name="ADM">
Abstract Data Model</a></h2>
<ul>
<li>The term "mesh" refers to an abstraction in the data model; it does not imply a serial or parallel distribution.</li><li>The term "partition" refers to an assignment of a set of entities to subsets; like a "mesh," it does not imply a serial or parallel implementation.</li><li>An application may use one or more meshes.</li><li>A paritition can create subsets of entities from a mesh.</li><li>Meshes can be subdivided by one or more partitions.</li><li>Partitions contain parts. Parts contain the subsets of entities in the partition.</li></ul>
<h2><a class="anchor" name="PAR">
Parallelism</a></h2>
<ul>
<li>A "process" can be thought of as an MPI process. The number of processes can be considered to be the result of MPI_Comm_size. The rank of a process can be thought of as the result of MPI_Comm_rank. We will think in terms of processes rather than processors. Initial implementations of the parallel interface will likely use MPI terminology directly; future implementations may accommodate other communication paradigms and libraries.</li><li>Partitions have communicators associated with them. These communicators can be thought of as MPI communicators.</li><li>"Global" operations are operations performed with respect to a partition's communicator.</li><li>"Local" operations are operations performed with respect to a part or a mesh instance within a process.</li><li>Part A "neighbors" Part B if Part A has copies of entities owned by Part B and/or if Part B has copies of entities owned by Part A.</li></ul>
<h2><a class="anchor" name="INT">
Interfaces</a></h2>
<ul>
<li>Each process has one or more "mesh instances." A mesh instance can be thought of as a mesh database. An implementation should support the existence of more than one mesh instance per process (e.g., it should always associate mesh data with a mesh instance). However, we expect applications would most often use only one mesh instance per process.</li><li>There is one root set per mesh instance.</li><li>Many iMeshP functions are analogous to functions in iMesh. Examples include iMeshP_getNumOfType, iMeshP_getNumOfTopo, iMeshP_getEntities, and iMeshP_initEntIter, but there are many others. These functions accept both an entity set handle and a part handle, to allow operations like returning all entities in a given part (represented by a part handle) with a given boundary condition (represented by an entity set). When the entity set is the root set, users may either pass the root set to these functions or pass the part handle as the entity set in the analogous iMesh function.</li><li>Similarly, iMeshP file I/O closely aligns with iMesh file I/O. The major change is the addition of a iMeshP_PartitionHandle argument to both iMeshP_loadAll and iMeshP_saveAll, enabling I/O from parallel processes and the initialization of the partition describing the data distribution.</li><li>Generation and management of global IDs for entities is not included in the iMeshP interface. It can be provided as a service above the iMeshP interface. Uniqueness of global IDs is managed at the partition level.</li></ul>
<h2><a class="anchor" name="PTN">
Using Partitions</a></h2>
<ul>
<li>A partition assigns entities from one mesh instance to parts.</li><li>Each process may have one or more partition handles.</li><li>Entities in a mesh instance can be partitioned by one or more partitions. Mesh instances know which partitions they contain.</li><li>Users build partitions by<ul>
<li>(1) creating a partition handle on each process to be included in the partition;</li><li>(2) adding parts to the partition handle within the process;</li><li>(3) populating the parts with entities; and</li><li>(4) calling iMeshP_syncPartitionAll to allow the implementation to compute global data for the partition.</li></ul>
</li><li>Implementations of iMeshP_loadAll will perform these steps for the application using the given partition handle.</li></ul>
<h2><a class="anchor" name="PRT">
Using Parts</a></h2>
<ul>
<li>Each part is wholly contained within a process.</li><li>A process may have zero, one or multiple parts.</li><li>Parts are uniquely identified globally by part IDs of type iMeshP_Part. Local parts can also be accessed by part handles that provide more direct access to a part.</li><li>Functions accepting part handles operate correctly on only local parts (parts on the calling process); they will return an error for remote (off-process) parts.</li><li>Functions that return entity information for a part, set or mesh instance return the information for all entities (including copies and ghosts) in that part, set or mesh instance. Applications can check whether an entity is owned or a ghost using iMeshP_isEntOwner or iMeshP_getEntStatus.</li><li>For each entity that is copied onto remote parts, the owning part knows both the remote part ID and remote entity handle of all copies.</li><li>All parts with copies of a boundary entity know the remote part ID and remote entity handle of all copies of the entity.</li><li>All parts with copies of any entity know the part ID and entity handle corresponding to the owner of the entity.</li><li>Many iMesh functions that accept an iBase_EntitySetHandle are also useful in the context of a iMeshP_PartHandle. These functions are reinterpreted so that they can accept either an iBase_EntitySetHandle or an iMeshP_PartHandle.</li><li>In particular, entities are added to and removed from local parts via the same functions that are used to manipulate entity sets. That is, given a mesh instance, an entity handle, and a part handle, the entity is added to or removed from the part via calls to the following functions with the part handle passed as the entity set handle:<ul>
<li>Add entity to part --&gt; iMesh_addEntToSet</li><li>Remove entity from part --&gt; iMesh_rmvEntFromSet</li><li>Add array of entities to part --&gt; iMesh_addEntArrToSet</li><li>Remove array of entities from part --&gt; iMesh_rmvEntArrFromSet</li></ul>
</li><li>iMeshP does not provide the capability to move entire parts to new processes; instead, the new process must create the part in its partition handle and then receive the entities to populate the part. In other words, parts can be added to only a local partition handle.</li></ul>
<h2><a class="anchor" name="CMM">
Communication</a></h2>
<ul>
<li>Each function description includes its communication requirements. The options are described here:<ul>
<li>COMMUNICATION: Collective -- the function must be called by all processes in the partition's communicator. (These functions have the suffix "All" to indicate collective communication is done.)</li><li>COMMUNICATION: Point-to-Point -- communication is used, but the communication is from one process to only one other process. The receiving process must issue an appropriate receive call to receive the message.</li><li>COMMUNICATION: None -- the function does not use communication; only local operations are performed.</li><li>COMMUNICATION: None++ -- no communication is done; the values are precomputed by iMeshP_syncPartitionAll or iMeshP_syncMeshAll.</li></ul>
</li><li>Non-blocking calls for off-processor mesh-modification return a request that indicates whether or not the operation has completed. The request is more than an MPI request; it encapsulates both the MPI information and the mesh operations that were requested. If non-blocking calls are used, appropriate calls to iMeshP "wait" or "poll" functions must be used to handle and satisfy requests. </li></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Apr 7 10:19:28 2009 for iMeshP by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7 </small></address>
</body>
</html>
