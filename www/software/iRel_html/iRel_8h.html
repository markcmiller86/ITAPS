<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>iRel: iRel.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>iRel.h File Reference</h1><code>#include "iGeom.h"</code><br>
<code>#include "iMesh.h"</code><br>
<code>#include "iRel_protos.h"</code><br>

<p>
<a href="iRel_8h-source.html">Go to the source code of this file.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a0">iRel_Instance</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type used to store iRel interface handle.  <a href="#a0"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>typedef void *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type used to store references to relation pairs.  <a href="#a1"></a><br><br></td></tr>
<tr><td colspan=2><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>enum &nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a27">IfaceType</a> { <br>
&nbsp;&nbsp;<a class="el" href="iRel_8h.html#a27a3">iRel_IBASE_IFACE</a> =  0, 
<a class="el" href="iRel_8h.html#a27a4">iRel_IGEOM_IFACE</a>, 
<a class="el" href="iRel_8h.html#a27a5">iRel_IMESH_IFACE</a>, 
<a class="el" href="iRel_8h.html#a27a6">iRel_IFIELD_IFACE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="iRel_8h.html#a27a7">iRel_IREL_IFACE</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">IfaceType Enumerator specifying interface types  <a href="#a27">More...</a><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a8">iRel_dtor</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">iRel_dtor Destroy the interface object  <a href="#a8"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a9">iRel_createAssociation</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, iBase_Instance iface1, const int ent_or_set1, const int iface_type1, iBase_Instance iface2, const int ent_or_set2, const int iface_type2, <a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a> *rel, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a relation pair between two interfaces.  <a href="#a9"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a10">iRel_destroyAssociation</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, <a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a> rel, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destroy a relation pair.  <a href="#a10"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a11">iRel_getAssociatedInterfaces</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, iBase_Instance iface, iBase_Instance **interfaces, int *interfaces_allocated, int *interfaces_size, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get interfaces related to specified interface.  <a href="#a11"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a12">iRel_setEntEntAssociation</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, <a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a> rel, iBase_EntityHandle ent1, int is_set1, iBase_EntityHandle ent2, int is_set2, int *ierr)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a13">iRel_setEntArrAssociation</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, <a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a> rel, iBase_EntityHandle ent1, int is_set1, int switch_order, iBase_EntityHandle *ent_array_2, int num_entities, int is_set2, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a relation between an entity and several entities.  <a href="#a13"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a14">iRel_setArrAssociation</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, <a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a> rel, iBase_EntityHandle *ent_array_1, int num_ent1, int is_set1, iBase_EntityHandle *ent_array_2, int num_ent2, int is_set2, int *ierr)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a15">iRel_getEntEntAssociation</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, <a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a> rel, iBase_EntityHandle ent1, int is_set1, int switch_order, iBase_EntityHandle *ent2, int *is_set2, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get entity related to specified entity and relation handle.  <a href="#a15"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a16">iRel_getEntArrAssociation</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, <a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a> rel, iBase_EntityHandle ent1, int is_set1, int return_sets, int switch_order, iBase_EntityHandle **ent_array_2, int *ent_array_2_allocated, int *ent_array_2_size, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get entities related to specified entity and relation.  <a href="#a16"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a17">iRel_getArrAssociation</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, <a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a> rel, iBase_EntityHandle *ent_array_1, int ent_array_1_size, int is_set1, int return_sets, int switch_order, iBase_EntityHandle **ent_array_2, int *ent_array_2_allocated, int *ent_array_2_size, int **offset, int *offset_allocated, int *offset_size, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get entities related to those in specified array and relation, pairwise.  <a href="#a17"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a18">iRel_createVtxAndAssociate</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, double x, double y, double z, iBase_EntityHandle associatedGeomEnt, iBase_EntityHandle *new_entity_handle, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a mesh vertex and relate to geometry entity.  <a href="#a18"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a19">iRel_createEntAndAssociate</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, int new_entity_topology, iBase_EntityHandle *lower_order_entity_handles, int lower_order_entity_handles_size, iBase_EntityHandle associatedGeomEnt, iBase_EntityHandle *new_entity_handle, int *creation_status, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a mesh entity and relate to geometry entity.  <a href="#a19"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a20">iRel_createVtxArrAndAssociate</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, int num_verts, int storage_order, double *new_coords, int new_coords_size, iBase_EntityHandle *associatedGeomEnts, int num_geom_ents, iBase_EntityHandle **new_vertex_handles, int *new_vertex_handles_allocated, int *new_vertex_handles_size, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an array of mesh vertices and relate to geometry entities.  <a href="#a20"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a21">iRel_createEntArrAndAssociate</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, int new_entity_topology, iBase_EntityHandle *lower_order_entity_handles, int lower_order_entity_handles_size, int *offsets, int offsets_size, iBase_EntityHandle *associatedGeomEnts, int num_geom_ents, iBase_EntityHandle **new_entity_handles, int *new_entity_handles_allocated, int *new_entity_handles_size, int **status, int *status_allocated, int *status_size, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create an array of mesh entities and relate to geometry entities.  <a href="#a21"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a22">iRel_inferAllAssociations</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, <a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a> rel, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Infer relations between entities in specified pair of interfaces.  <a href="#a22"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a23">iRel_inferEntAssociations</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, <a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a> rel, iBase_EntityHandle entity, int is_set, int iface_no, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Infer relations corresponding to specified entity and relation pair.  <a href="#a23"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a24">iRel_inferArrAssociations</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, <a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a> rel, iBase_EntityHandle *entities, int entities_size, int is_set, int iface_no, int *ierr)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Infer relations corresponding to specified entities and relation pair.  <a href="#a24"></a><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a25">iRel_moveTo</a> (<a class="el" href="iRel_8h.html#a0">iRel_Instance</a> instance, iGeom_Instance geom, iMesh_Instance mesh, iBase_EntityHandle geom_entity_handle, int *ierr)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a26">iRel_newAssoc</a> (const char *options, <a class="el" href="iRel_8h.html#a0">iRel_Instance</a> *instance, int *ierr, const int options_len)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a new iRel instance.  <a href="#a26"></a><br><br></td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>iBase_Error&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="iRel_8h.html#a2">iRel_LAST_ERROR</a></td></tr>

</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a0" doxytag="iRel.h::iRel_Instance" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef void* <a class="el" href="iRel_8h.html#a0">iRel_Instance</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Type used to store iRel interface handle     </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="iRel.h::iRel_RelationHandle" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef void* <a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Type used to store references to relation pairs     </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="a27" doxytag="iRel.h::IfaceType" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum <a class="el" href="iRel_8h.html#a27">IfaceType</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Enumerator specifying interface types. This enumeration is necessary because functions to get entities of a given dimension are part of the higher-level interfaces (e.g. iGeom, iMesh) instead of iBase. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a class="anchor" name="a27a3" doxytag="iRel_IBASE_IFACE" ></a>iRel_IBASE_IFACE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="a27a4" doxytag="iRel_IGEOM_IFACE" ></a>iRel_IGEOM_IFACE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="a27a5" doxytag="iRel_IMESH_IFACE" ></a>iRel_IMESH_IFACE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="a27a6" doxytag="iRel_IFIELD_IFACE" ></a>iRel_IFIELD_IFACE</em>&nbsp;</td><td>
</td></tr>
<tr><td valign=top><em><a class="anchor" name="a27a7" doxytag="iRel_IREL_IFACE" ></a>iRel_IREL_IFACE</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a9" doxytag="iRel.h::iRel_createAssociation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_createAssociation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_Instance&nbsp;</td>
          <td class="mdname" nowrap> <em>iface1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_or_set1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>iface_type1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_Instance&nbsp;</td>
          <td class="mdname" nowrap> <em>iface2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_or_set2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>iface_type2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>rel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates a relation pair between two interfaces, passing back a handle to the pair. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>iface1</em>&nbsp;</td><td>1st interface object in the relation pair </td></tr>
    <tr><td valign=top><em>ent_or_set1</em>&nbsp;</td><td>This relation relates entities (=0) or sets (=1) or both (=2) from 1st interface object </td></tr>
    <tr><td valign=top><em>iface_type1</em>&nbsp;</td><td>Type of 1st interface (0=iBase, 1=iGeom, 2=iMesh, 3=iField, 4=iRel) </td></tr>
    <tr><td valign=top><em>iface2</em>&nbsp;</td><td>2nd interface object in the relation pair </td></tr>
    <tr><td valign=top><em>ent_or_set2</em>&nbsp;</td><td>This relation relates entities (=0) or sets (=1) or both (=2) from 2nd interface object </td></tr>
    <tr><td valign=top><em>iface_type2</em>&nbsp;</td><td>Type of 2nd interface (0=iBase, 1=iGeom, 2=iMesh, 3=iField, 4=iRel) </td></tr>
    <tr><td valign=top><em>*rel</em>&nbsp;</td><td>Pointer to relation handle, returned from function </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a19" doxytag="iRel.h::iRel_createEntAndAssociate" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_createEntAndAssociate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>new_entity_topology</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle *&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_order_entity_handles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_order_entity_handles_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle&nbsp;</td>
          <td class="mdname" nowrap> <em>associatedGeomEnt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle *&nbsp;</td>
          <td class="mdname" nowrap> <em>new_entity_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>creation_status</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a mesh entity and relate to geometry entity. Relation pair instance must be between geometry instance and mesh instance, and must have instances in that order (geometry, mesh). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>new_entity_topology</em>&nbsp;</td><td>Topology type of new mesh entity (from iMesh Topology enum) </td></tr>
    <tr><td valign=top><em>lower_order_entity_handles</em>&nbsp;</td><td>Handles of lower dimension entities bounding new mesh entity </td></tr>
    <tr><td valign=top><em>lower_order_entity_handles_size</em>&nbsp;</td><td>Number of lower dimension entities in lower_order_entity_handles array </td></tr>
    <tr><td valign=top><em>associatedGeomEnt</em>&nbsp;</td><td>Geometry entity to be related to new vertex </td></tr>
    <tr><td valign=top><em>*new_entity_handle</em>&nbsp;</td><td>Pointer to new mesh entity handle </td></tr>
    <tr><td valign=top><em>*creation_status</em>&nbsp;</td><td>Creation status of new entity (from iBase CreationStatus enum) </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a21" doxytag="iRel.h::iRel_createEntArrAndAssociate" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_createEntArrAndAssociate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>new_entity_topology</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle *&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_order_entity_handles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>lower_order_entity_handles_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>offsets</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>offsets_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle *&nbsp;</td>
          <td class="mdname" nowrap> <em>associatedGeomEnts</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_geom_ents</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle **&nbsp;</td>
          <td class="mdname" nowrap> <em>new_entity_handles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>new_entity_handles_allocated</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>new_entity_handles_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>status</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>status_allocated</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>status_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an array of mesh entities and relate to one or more geometry entities. If only one geometry entity is input, entities are all related to that entity; otherwise the number of new entities and input geometric entities must be identical. Relation pair instance must be between geometry instance and mesh instance, and must have instances in that order (geometry, mesh). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>new_entity_topology</em>&nbsp;</td><td>Topology type of new mesh entity (from iMesh Topology enum) </td></tr>
    <tr><td valign=top><em>lower_order_entity_handles</em>&nbsp;</td><td>Handles of lower dimension entities bounding new mesh entity </td></tr>
    <tr><td valign=top><em>lower_order_entity_handles_size</em>&nbsp;</td><td>Number of lower dimension entities in lower_order_entity_handles array </td></tr>
    <tr><td valign=top><em>offsets</em>&nbsp;</td><td>Offset array; offset[i] is index into lower_order_entity_handles for i'th new entity </td></tr>
    <tr><td valign=top><em>offsets_size</em>&nbsp;</td><td>Size of offset array, also equal to one more than number of new entities to be created </td></tr>
    <tr><td valign=top><em>*associatedGeomEnts</em>&nbsp;</td><td>Geometry entities to be related to new vertices </td></tr>
    <tr><td valign=top><em>num_geom_ents</em>&nbsp;</td><td>Number of geometry entities</td></tr>
    <tr><td valign=top><em>*new_entity_handles</em>&nbsp;</td><td>Pointer to array of returned entity handles </td></tr>
    <tr><td valign=top><em>*new_entity_handles_allocated</em>&nbsp;</td><td>Pointer to allocated size of new entity handle array </td></tr>
    <tr><td valign=top><em>*new_entity_handles_size</em>&nbsp;</td><td>Pointer to occupied size of new entity handle array </td></tr>
    <tr><td valign=top><em>*status</em>&nbsp;</td><td>Creation status of new entities (from iBase CreationStatus enum) </td></tr>
    <tr><td valign=top><em>*status_allocated</em>&nbsp;</td><td>Allocated size of status array </td></tr>
    <tr><td valign=top><em>*status_size</em>&nbsp;</td><td>Occupied size of status array </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a18" doxytag="iRel.h::iRel_createVtxAndAssociate" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_createVtxAndAssociate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>y</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>z</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle&nbsp;</td>
          <td class="mdname" nowrap> <em>associatedGeomEnt</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle *&nbsp;</td>
          <td class="mdname" nowrap> <em>new_entity_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a mesh vertex and relate to geometry entity. Relation pair instance must be between geometry instance and mesh instance, and must have instances in that order (geometry, mesh). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>x</em>&nbsp;</td><td>X position of new mesh vertex </td></tr>
    <tr><td valign=top><em>y</em>&nbsp;</td><td>Y position of new mesh vertex </td></tr>
    <tr><td valign=top><em>z</em>&nbsp;</td><td>Z position of new mesh vertex </td></tr>
    <tr><td valign=top><em>associatedGeomEnt</em>&nbsp;</td><td>Geometry entity to be related to new vertex </td></tr>
    <tr><td valign=top><em>*new_entity_handle</em>&nbsp;</td><td>Pointer to new mesh vertex handle </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a20" doxytag="iRel.h::iRel_createVtxArrAndAssociate" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_createVtxArrAndAssociate </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_verts</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>storage_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>double *&nbsp;</td>
          <td class="mdname" nowrap> <em>new_coords</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>new_coords_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle *&nbsp;</td>
          <td class="mdname" nowrap> <em>associatedGeomEnts</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_geom_ents</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle **&nbsp;</td>
          <td class="mdname" nowrap> <em>new_vertex_handles</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>new_vertex_handles_allocated</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>new_vertex_handles_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create an array of mesh vertices and relate to one or more geometry entities. If only one geometry entity is input, vertices are all related to that entity; otherwise the number of new vertices and input geometric entities must be identical. Relation pair instance must be between geometry instance and mesh instance, and must have instances in that order (geometry, mesh). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>num_verts</em>&nbsp;</td><td>Number of new vertices to be created </td></tr>
    <tr><td valign=top><em>storage_order</em>&nbsp;</td><td>Storage order of coordinate array (from iBase StorageOrder enum, either iBase_BLOCKED or iBase_INTERLEAVED) </td></tr>
    <tr><td valign=top><em>new_coords</em>&nbsp;</td><td>Positions of new mesh vertices </td></tr>
    <tr><td valign=top><em>new_coords_size</em>&nbsp;</td><td>Number of position entries in new_coords </td></tr>
    <tr><td valign=top><em>*associatedGeomEnts</em>&nbsp;</td><td>Geometry entities to be related to new vertices </td></tr>
    <tr><td valign=top><em>num_geom_ents</em>&nbsp;</td><td>Number of geometry entities </td></tr>
    <tr><td valign=top><em>*new_vertex_handles</em>&nbsp;</td><td>Pointer to array of returned vertex handles </td></tr>
    <tr><td valign=top><em>*new_vertex_handles_allocated</em>&nbsp;</td><td>Pointer to allocated size of new vertex handle array </td></tr>
    <tr><td valign=top><em>*new_vertex_handles_size</em>&nbsp;</td><td>Pointer to occupied size of new vertex handle array </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="iRel.h::iRel_destroyAssociation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_destroyAssociation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>rel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destroy the relation pair corresponding to the handle input <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>rel</em>&nbsp;</td><td>Handle of relation pair to destroy </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="iRel.h::iRel_dtor" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_dtor </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calls destructor on interface object <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface object handle to destroy </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a17" doxytag="iRel.h::iRel_getArrAssociation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_getArrAssociation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>rel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle *&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_array_1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_array_1_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>is_set1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>return_sets</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>switch_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle **&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_array_2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_array_2_allocated</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_array_2_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int **&nbsp;</td>
          <td class="mdname" nowrap> <em>offset</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>offset_allocated</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>offset_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get entities related to those in specified array and relation, pairwise. Returns sets or entities, depending on relation type and entities in ent_array_1. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>rel</em>&nbsp;</td><td>Relation handle being queried </td></tr>
    <tr><td valign=top><em>ent_array_1</em>&nbsp;</td><td>Array of entities whose relations are being queried </td></tr>
    <tr><td valign=top><em>ent_array_1_size</em>&nbsp;</td><td>Number of entities in ent_array_1 </td></tr>
    <tr><td valign=top><em>is_set1</em>&nbsp;</td><td>ent_array_1 contains entities (=0) or sets (=1) </td></tr>
    <tr><td valign=top><em>return_sets</em>&nbsp;</td><td>If zero and target side of the relation is of type 'set' or 'both', return entities in related sets; if non-zero, return sets; if target is of type 'entity', disregard this argument </td></tr>
    <tr><td valign=top><em>switch_order</em>&nbsp;</td><td>Entities in ent_array_1 are associated with 1st (=0) or 2nd (=1) interface of this relation pair </td></tr>
    <tr><td valign=top><em>*ent_array_2</em>&nbsp;</td><td>Pointer to array of entity handles returned from function </td></tr>
    <tr><td valign=top><em>*ent_array_2_allocated</em>&nbsp;</td><td>Pointer to allocated size of ent_array_2 </td></tr>
    <tr><td valign=top><em>*ent_array_2_size</em>&nbsp;</td><td>Pointer to occupied size of ent_array_2 </td></tr>
    <tr><td valign=top><em>*offset</em>&nbsp;</td><td>Pointer to offset array; (*offset)[i] is index into (*ent_array_2) of 1st relation of ent_array_1[i] </td></tr>
    <tr><td valign=top><em>*offset_allocated</em>&nbsp;</td><td>Pointer to allocated size of offset </td></tr>
    <tr><td valign=top><em>*offset_size</em>&nbsp;</td><td>Pointer to occupied size of offset </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="iRel.h::iRel_getAssociatedInterfaces" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_getAssociatedInterfaces </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_Instance&nbsp;</td>
          <td class="mdname" nowrap> <em>iface</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_Instance **&nbsp;</td>
          <td class="mdname" nowrap> <em>interfaces</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>interfaces_allocated</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>interfaces_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get interfaces related to the specified interface <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>iface</em>&nbsp;</td><td>Specified interface </td></tr>
    <tr><td valign=top><em>interfaces</em>&nbsp;</td><td>Pointer to array holding returned interfaces related to specified interface </td></tr>
    <tr><td valign=top><em>interfaces_allocated</em>&nbsp;</td><td>Pointer to allocated size of interfaces list </td></tr>
    <tr><td valign=top><em>interfaces_size</em>&nbsp;</td><td>Pointer to occupied size of interfaces list </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a16" doxytag="iRel.h::iRel_getEntArrAssociation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_getEntArrAssociation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>rel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle&nbsp;</td>
          <td class="mdname" nowrap> <em>ent1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>is_set1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>return_sets</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>switch_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle **&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_array_2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_array_2_allocated</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_array_2_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get entities related to specified entity and relation; returns entity sets or contained entities, depending on relation type (entity, set, or both) and return_sets argument <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>rel</em>&nbsp;</td><td>Relation handle being queried </td></tr>
    <tr><td valign=top><em>ent1</em>&nbsp;</td><td>1st entity of relation being queried </td></tr>
    <tr><td valign=top><em>is_set1</em>&nbsp;</td><td>ent1 is an entity (=0) or a set (=1) </td></tr>
    <tr><td valign=top><em>return_sets</em>&nbsp;</td><td>If zero and target side of the relation is of type 'set' or 'both', return entities in related set; if non-zero, return set; if target is of type 'entity', disregard this argument </td></tr>
    <tr><td valign=top><em>switch_order</em>&nbsp;</td><td>ent1 is associated with 1st (=0) or 2nd (=1) interface of this relation pair </td></tr>
    <tr><td valign=top><em>*ent_array_2</em>&nbsp;</td><td>Pointer to array of entity handles returned from function </td></tr>
    <tr><td valign=top><em>*ent_array_2_allocated</em>&nbsp;</td><td>Pointer to allocated size of ent_array_2 </td></tr>
    <tr><td valign=top><em>*ent_array_2_size</em>&nbsp;</td><td>Pointer to occupied size of ent_array_2 </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a15" doxytag="iRel.h::iRel_getEntEntAssociation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_getEntEntAssociation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>rel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle&nbsp;</td>
          <td class="mdname" nowrap> <em>ent1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>is_set1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>switch_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle *&nbsp;</td>
          <td class="mdname" nowrap> <em>ent2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>is_set2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get entity related to specified entity and relation handle. Also returns whether the related entity is an entity or a set. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>rel</em>&nbsp;</td><td>Relation handle being queried </td></tr>
    <tr><td valign=top><em>ent1</em>&nbsp;</td><td>1st entity of relation being queried </td></tr>
    <tr><td valign=top><em>is_set1</em>&nbsp;</td><td>1st entity is an entity (=0) or a set (=1) </td></tr>
    <tr><td valign=top><em>switch_order</em>&nbsp;</td><td>1st entity is related to 1st interface (=0) or 2nd interface (=1) of relation pair </td></tr>
    <tr><td valign=top><em>*ent2</em>&nbsp;</td><td>Pointer to entity related to ent1 </td></tr>
    <tr><td valign=top><em>*is_set2</em>&nbsp;</td><td>Pointer to flag telling whether *ent2 is an entity (=0) or a set (=1) </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a22" doxytag="iRel.h::iRel_inferAllAssociations" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_inferAllAssociations </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>rel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Infer relations between entities in specified pair of interfaces. The criteria used to infer these relations depends on the interfaces in the pair, the iRel implementation, and the source of the data in those interfaces. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>rel</em>&nbsp;</td><td>Relation handle being queried </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a24" doxytag="iRel.h::iRel_inferArrAssociations" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_inferArrAssociations </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>rel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle *&nbsp;</td>
          <td class="mdname" nowrap> <em>entities</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>entities_size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>is_set</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iface_no</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Infer relations corresponding to specified entities and relation pair. The criteria used to infer these relations depends on the interfaces in the pair, the iRel implementation, and the source of the data in those interfaces. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>rel</em>&nbsp;</td><td>Relation handle being queried </td></tr>
    <tr><td valign=top><em>entities</em>&nbsp;</td><td>Array of entities whose relation are being inferred </td></tr>
    <tr><td valign=top><em>entities_size</em>&nbsp;</td><td>Number of entities in array </td></tr>
    <tr><td valign=top><em>is_set</em>&nbsp;</td><td>Entities are regular entities (=0) or sets (=1) </td></tr>
    <tr><td valign=top><em>iface_no</em>&nbsp;</td><td>Entities correspond to 1st (=0) or 2nd (=1) interface in relation pair </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a23" doxytag="iRel.h::iRel_inferEntAssociations" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_inferEntAssociations </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>rel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle&nbsp;</td>
          <td class="mdname" nowrap> <em>entity</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>is_set</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>iface_no</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Infer relations corresponding to specified entity and relation pair. The criteria used to infer these relations depends on the interfaces in the pair, the iRel implementation, and the source of the data in those interfaces. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>rel</em>&nbsp;</td><td>Relation handle being queried </td></tr>
    <tr><td valign=top><em>entity</em>&nbsp;</td><td>Entity whose relations are being inferred </td></tr>
    <tr><td valign=top><em>is_set</em>&nbsp;</td><td>Entity is a regular entity (=0) or a set (=1) </td></tr>
    <tr><td valign=top><em>iface_no</em>&nbsp;</td><td>Entity corresponds to 1st (=0) or 2nd (=1) interface in relation pair </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a25" doxytag="iRel.h::iRel_moveTo" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_moveTo </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iGeom_Instance&nbsp;</td>
          <td class="mdname" nowrap> <em>geom</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iMesh_Instance&nbsp;</td>
          <td class="mdname" nowrap> <em>mesh</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle&nbsp;</td>
          <td class="mdname" nowrap> <em>geom_entity_handle</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Move related mesh entities to the closest point on the specified geometry entity. There must exist a relation pair instance between the input geometry and mesh instances, with those instances in that order (geometry, mesh). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>geom</em>&nbsp;</td><td>iGeom instance handle </td></tr>
    <tr><td valign=top><em>mesh</em>&nbsp;</td><td>iMesh instance handle </td></tr>
    <tr><td valign=top><em>geom_entity_handle</em>&nbsp;</td><td>Geometry entity whose related entities are being moved to it </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a26" doxytag="iRel.h::iRel_newAssoc" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_newAssoc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>options</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="iRel_8h.html#a0">iRel_Instance</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap> <em>options_len</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new iRel instance. Currently no options are implemented. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>options</em>&nbsp;</td><td>Options for the implementation </td></tr>
    <tr><td valign=top><em>*instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
    <tr><td valign=top><em>options_len</em>&nbsp;</td><td>Length of options string </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="iRel.h::iRel_setArrAssociation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_setArrAssociation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>rel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle *&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_array_1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_ent1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>is_set1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle *&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_array_2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_ent2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>is_set2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set relations between arrays of entities pairwise, ent_array_1[i]&lt;-&gt;ent_array_2[i]. If either array contains sets and that side of the relation is 'both'-type, set relations for individual entities in those sets too. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>rel</em>&nbsp;</td><td>Relation handle being queried </td></tr>
    <tr><td valign=top><em>ent_array_1</em>&nbsp;</td><td>1st array of entities of relation being set </td></tr>
    <tr><td valign=top><em>num_ent1</em>&nbsp;</td><td>Number of entities in 1st array </td></tr>
    <tr><td valign=top><em>is_set1</em>&nbsp;</td><td>1st array contains entities (=0) or sets (=1) </td></tr>
    <tr><td valign=top><em>ent_array_2</em>&nbsp;</td><td>2nd array of entities of relation being set </td></tr>
    <tr><td valign=top><em>num_ent2</em>&nbsp;</td><td>Number of entities in 2nd array </td></tr>
    <tr><td valign=top><em>is_set2</em>&nbsp;</td><td>2nd array contains entities (=0) or sets (=1) </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="iRel.h::iRel_setEntArrAssociation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_setEntArrAssociation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>rel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle&nbsp;</td>
          <td class="mdname" nowrap> <em>ent1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>is_set1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>switch_order</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle *&nbsp;</td>
          <td class="mdname" nowrap> <em>ent_array_2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_entities</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>is_set2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set a relation between an entity and several entities. If either is a set and that side of the relation is 'both'-type, set relations for individual entities in that set too. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>rel</em>&nbsp;</td><td>Relation handle being queried </td></tr>
    <tr><td valign=top><em>ent1</em>&nbsp;</td><td>1st entity of relation being set </td></tr>
    <tr><td valign=top><em>is_set1</em>&nbsp;</td><td>ent1 is an entity (=0) or a set (=1) </td></tr>
    <tr><td valign=top><em>switch_order</em>&nbsp;</td><td>If non-zero, ent1 is associated with iface2 and ent_array_2 with iface1 of specified relation, otherwise vica versa </td></tr>
    <tr><td valign=top><em>ent_array_2</em>&nbsp;</td><td>Entity(ies) to be related to ent1 </td></tr>
    <tr><td valign=top><em>num_entities</em>&nbsp;</td><td>Number of entities in ent_array_2 </td></tr>
    <tr><td valign=top><em>is_set2</em>&nbsp;</td><td>Entities in ent_array_2 are entities (=0) or sets (=1) </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="iRel.h::iRel_setEntEntAssociation" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void iRel_setEntEntAssociation </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="iRel_8h.html#a0">iRel_Instance</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>instance</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="iRel_8h.html#a1">iRel_RelationHandle</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>rel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle&nbsp;</td>
          <td class="mdname" nowrap> <em>ent1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>is_set1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>iBase_EntityHandle&nbsp;</td>
          <td class="mdname" nowrap> <em>ent2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>is_set2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>ierr</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign=top><em>instance</em>&nbsp;</td><td>Interface instance </td></tr>
    <tr><td valign=top><em>rel</em>&nbsp;</td><td>Relation handle being queried </td></tr>
    <tr><td valign=top><em>ent1</em>&nbsp;</td><td>1st entity of relation being set </td></tr>
    <tr><td valign=top><em>is_set1</em>&nbsp;</td><td>ent1 is an entity (=0) or a set (=1) </td></tr>
    <tr><td valign=top><em>ent2</em>&nbsp;</td><td>2nd entity of relation being set </td></tr>
    <tr><td valign=top><em>is_set2</em>&nbsp;</td><td>ent2 is an entity (=0) or a set (=1) </td></tr>
    <tr><td valign=top><em>*ierr</em>&nbsp;</td><td>Pointer to error value, returned from function </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="a2" doxytag="iRel.h::iRel_LAST_ERROR" ></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> struct iBase_Error <a class="el" href="iRel_8h.html#a2">iRel_LAST_ERROR</a>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jun 26 11:09:21 2007 for iRel by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
