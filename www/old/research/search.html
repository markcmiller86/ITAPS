<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html><head><title>Point/Element Search Service</title>




     <link type="text/css" rel="stylesheet" href="/templates/stylesheet.css" /></head><body>
<div id="container">

<div id="banner"><img alt="ITAPS" src="../graphics/banner.gif" /> <br /></div>

<div id="menu"><!--#include virtual="/templates/menu.html"--> </div>

<div id="content">
<h1>Point/Element Search Service</h1>

<p>It is a common procedure to search a given mesh to determine the
mesh entities that contain a set of points.  Examples of this include
synthetic diagnostics and field transfer during mesh adaptation.  This
can become a computationally expensive operation if the search
procedure is not organized.  The best search procedure depends on the
organization and number of search points.  Two point/element search
algorithms have been developed.

</p><p>The first is a line-search algorithm.  It assumes that there are a 
¡Èsmall¡É number of points being searched, that the points are ordered
such that consecutive points are ¡Èclose¡É to each other, and that,
other that maybe a very small number, all of the points are in the
domain of the mesh.  The algorithm requires no setup beyond loading
the mesh.  The algorithm is initiated by starting from the mesh region
returned from the last successful mesh search (or a random mesh region
if no previous successful searches have been performed).  The
algorithm proceeds by determining if the given point is in the domain
of the mesh region and if it is, it returns the mesh region.  If the
point is outside the domain of the mesh region, the algorithm marks
the mesh region as being searched and moves on to an adjacent mesh
region that is closest to the search point and continues the search.
If all adjacent mesh regions are marked then the search is continued
with a random unmarked mesh region.  The figure below shows an example
of the line search algorithm in 2 dimensions.</p>
<br />


<p><img src="../graphics/linesearch.png" name="Graphic1" align="middle" border="0" height="206" width="294" /><br />
</p>
<br />
<p class="western" style="margin-bottom: 0in;" align="center">Figure 1:
An example of the line search algorithm for a 2D mesh.</p>

<p>The second search algorithm is an octree-based search algorithm.  This
algorithm recursively divides the domain of a mesh's bounding box into
octants.  The domain is subdivided locally such that the number of
mesh regions associated with a leaf octant (an octant without any
sub-octants) is bounded and balanced.  A mesh region is considered to
be associated with a leaf-octant if it is not determined that they do
not intersect.  Exact intersection between a mesh region's domain and
a leaf octant is expensive to compute so approximate intersection is
computed using a projection method to quickly eliminate candidates.

</p><p>After all of the mesh regions are associated with the proper leaf
octants, the setup is complete.  Searching the mesh for a given point
then involves determining which leaf octant the point is contained in
and then searching the mesh regions associated with that leaf octant
to determine if any of them contain the point in their domain.  Figure
2 shows an octree division of the bounding box of a mesh.</p><br />


<img src="../graphics/octreesearch.png" name="Graphic2" align="middle" border="0" height="221" width="317" /><br />
<br />
<p class="western" style="margin-bottom: 0in;" align="center">Figure 2:
An octree division of the bounding box of a 2D mesh.</p>

<p>Deciding which of these two algorithms to use depends on a variety of
factors.  Some of these factors include how many search points there
are, the ordering of the search points, how many search points may be
outside the domain of the mesh, the size of the mesh, etc.  Both
algorithms were tested with 2 meshes with M1 having 38,400 mesh
regions and M2 having 557,568 mesh regions (both meshes are manifold
and have all prismatic mesh regions).  The setup time in seconds for
each mesh and algorithm is shown in Table 1.  Note that the mesh is
created from nodal coordinates and element connectivity information.
</p>
<br />

<table border="1" bordercolor="#000000" cellpadding="4" cellspacing="0" width="576">
	<col width="310" />
	<col width="122" />
	<col width="119" />
	<thead>
		<tr valign="top">
			<td width="310">
				<p class="ww-table-heading1-western"><br />
				</p>
			</td>
			<td width="122">
				<p class="western" align="center">M<sub>1</sub></p>
			</td>
			<td width="119">
				<p class="western" align="center">M<sub>2</sub></p>
			</td>
		</tr>
	</thead>
	<tbody>
		<tr valign="top">
			<td width="310">
				<p class="ww-table-contents1-western">Line Search Mesh Creation</p>
			</td>
			<td width="122">
				<p class="ww-table-contents1-western" align="center">1.59 (s)</p>
			</td>
			<td width="119">
				<p class="ww-table-contents1-western" align="center">22.7 (s)</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="310">
				<p class="ww-table-contents1-western">Octree-Based Search Mesh
				Creation</p>
			</td>
			<td width="122">
				<p class="ww-table-contents1-western" align="center">0.34 (s)</p>
			</td>
			<td width="119">
				<p class="ww-table-contents1-western" align="center">4.64 (s)</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="310">
				<p class="ww-table-contents1-western">Octree-Based Search
				Structure Creation</p>
			</td>
			<td width="122">
				<p class="ww-table-contents1-western" align="center">3.66 (s)</p>
			</td>
			<td width="119">
				<p class="ww-table-contents1-western" align="center">53.9 (s)</p>
			</td>
		</tr>
	</tbody>
</table>
<p class="western" style="margin-bottom: 0in;" align="center">Table 1:
Computation time in seconds for creating objects.</p>
<br />
<p>
For search efficiency, the two algorithms were compared for doing line
searches.  The results are given in Table 2.</p>

<table border="1" bordercolor="#000000" cellpadding="4" cellspacing="0" width="576">
	<col width="330" />
	<col width="84" />
	<col width="137" />
	<thead>
		<tr valign="top">
			<td width="330">
				<p class="ww-table-heading1-western"><br />
				</p>
			</td>
			<td width="84">
				<p class="ww-table-heading1-western" style="font-style: normal;">
				Line Search</p>
			</td>
			<td width="137">
				<p class="ww-table-heading1-western" style="font-style: normal;">
				Octree-Based Search</p>
			</td>
		</tr>
	</thead>
	<tbody>
		<tr valign="top">
			<td width="330">
				<p class="ww-table-contents1-western">M<sub>1</sub> with 96
				interior points out of 100</p>
			</td>
			<td width="84">
				<p class="ww-table-contents1-western" align="center">4.17 (s)</p>
			</td>
			<td width="137">
				<p class="ww-table-contents1-western" align="center">0.0025 (s)</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="330">
				<p class="ww-table-contents1-western">M<sub>1</sub> with 9,618
				interior points out of 10,000</p>
			</td>
			<td width="84">
				<p class="ww-table-contents1-western" align="center">398 (s)</p>
			</td>
			<td width="137">
				<p class="ww-table-contents1-western" align="center">0.929 (s)</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="330">
				<p class="ww-table-contents1-western">M<sub>1</sub> with 100
				interior points</p>
			</td>
			<td width="84">
				<p class="ww-table-contents1-western" align="center">0.0163 (s)</p>
			</td>
			<td width="137">
				<p class="ww-table-contents1-western" align="center">0.00645 (s)</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="330">
				<p class="ww-table-contents1-western">M<sub>1</sub> with 10,000
				interior points</p>
			</td>
			<td width="84">
				<p class="ww-table-contents1-western" align="center">0.411 (s)</p>
			</td>
			<td width="137">
				<p class="ww-table-contents1-western" align="center">0.0968 (s)</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="330">
				<p class="ww-table-contents1-western">M<sub>2 </sub>with 92
				interior points out of 100</p>
			</td>
			<td width="84">
				<p class="ww-table-contents1-western" align="center">125 (s)</p>
			</td>
			<td width="137">
				<p class="ww-table-contents1-western" align="center">0.00227 (s)</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="330">
				<p class="ww-table-contents1-western">M<sub>2 </sub>with 9,332
				interior points out of 10,000</p>
			</td>
			<td width="84">
				<p class="ww-table-contents1-western" align="center">10.989 (s)</p>
			</td>
			<td width="137">
				<p class="ww-table-contents1-western" align="center">0.0866 (s)</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="330">
				<p class="ww-table-contents1-western">M<sub>2 </sub>with 100
				interior points</p>
			</td>
			<td width="84">
				<p class="ww-table-contents1-western" align="center">0.0223 (s)</p>
			</td>
			<td width="137">
				<p class="ww-table-contents1-western" align="center">0.00765 (s)</p>
			</td>
		</tr>
		<tr valign="top">
			<td width="330">
				<p class="ww-table-contents1-western">M<sub>2 </sub>with 10,000
				interior points</p>
			</td>
			<td width="84">
				<p class="ww-table-contents1-western" align="center">0.412 (s)</p>
			</td>
			<td width="137">
				<p class="ww-table-contents1-western" align="center">0.103 (s)</p>
			</td>
		</tr>
	</tbody>
</table>
<p class="western" style="margin-bottom: 0in;" align="center">Table 2:
Compute times for line searches.</p>

<p>As can be seen from Table 2, the line search algorithm is only
slightly slower than the octree-based search algorithm when all of the
search points are in the domain of the mesh. Since the line search has
very small set-up time, it is superior when points are ordered and no
points are exterior. When any points are outside the domain, the line
search quickly becomes expensive since in that case it ends-up
checking all elements for such points. When there are large numbers of
more random points to be searched, the octree method is faster.

</p><p>Other search algorithms such as the popular ADT (or a pseudo ADT for
adapting meshes) can be implemented fairly quickly building on the
ITAPS infrastructure.<br />
</p>
<h1>Tree Searching (MOAB)</h1>
<p>MOAB provides a number of different tree structures for sorting (based on spatial decomposition) and searching on a mesh:<br />
</p>
<ul>
  <li>Adaptive kd Tree: These trees partition space using alternating coordinate axis split planes.&nbsp; Split planes are chosen based on positions of vertices in the mesh.&nbsp; <br />
  </li>
  <li>Binary Space Partition (BSP) Tree: These trees partition space
using planar partitions which may or may not correspond to a coordinate
plane.</li>
  <li>Hierarchical Oriented Bounding Box (hOBB) Tree: An Oriented Bounding Box encloses a collection of mesh entities
and is oriented to minimize one or more box dimensions.&nbsp; A HOBB is
a tree of OBBs, with the root of the tree surrounding all entities in a
collection, and child boxes chosen to approximately bisect the
collection along the longest principal axis of the parent box.&nbsp;
HOBBs are an efficient choice when doing ray tracing on large
collections of triangles, since they minimize the number of actual
ray-triangle intersections that must be tested.</li>
</ul>
The tree structures in MOAB are all stored using sets and tags, and can
be queried, saved, and restored through the iMesh interface.&nbsp; Each
tree class in MOAB provides functions for performing tree searches
specific to the tree type, but most also provide functions for finding
the leaf containing a position, finding the triangle closest to a given
position, and for traversing or iterating over the tree.<br />
<br />
<h3>Interaction with geometric models</h3>
Much of the tree searching in MOAB was developed for the purpose of
performing ray tracing or other searches on facets derived from
geometric (CAD) models.&nbsp; If MOAB is configured with CGM support,
then the facets and edges resolving CAD faces and edges are read into
MOAB, with the geometric topology represented using MOAB entity sets
(see MOAB documentation for details).&nbsp; MOAB tree structures can be
constructed based on those facets, and searched using the closest point
and ray tracing functions in the tree classes.<br />
<h3>Parallel tree evaluation</h3>
MOAB's kd Tree capability has been used to implement parallel solution
transfer, where a vertex-based solution field is transferred from one
mesh to another.&nbsp; An important part of this process is point
location, where for every point in one mesh one finds the containing
element, and processor that element is located on, in another
mesh.&nbsp; MOAB implements this capability as part of its MBCoupler
class.&nbsp; Solution transfer is described more fully <a href="http://www.itaps.org/research/solution_transfer.html">here</a>.<br />
<br />
<br />
<p>
 

</p>
</div>
</div>

</body></html>